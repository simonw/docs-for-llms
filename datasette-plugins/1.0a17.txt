<documents>
<document index="1">
<source>docs/plugins.rst</source>
<document_content>
.. _plugins:

Plugins
=======

Datasette's plugin system allows additional features to be implemented as Python
code (or front-end JavaScript) which can be wrapped up in a separate Python
package. The underlying mechanism uses `pluggy <https://pluggy.readthedocs.io/>`_.

See the `Datasette plugins directory <https://datasette.io/plugins>`__ for a list of existing plugins, or take a look at the
`datasette-plugin <https://github.com/topics/datasette-plugin>`__ topic on GitHub.

Things you can do with plugins include:

* Add visualizations to Datasette, for example
  `datasette-cluster-map <https://github.com/simonw/datasette-cluster-map>`__ and
  `datasette-vega <https://github.com/simonw/datasette-vega>`__.
* Make new custom SQL functions available for use within Datasette, for example
  `datasette-haversine <https://github.com/simonw/datasette-haversine>`__ and
  `datasette-jellyfish <https://github.com/simonw/datasette-jellyfish>`__.
* Define custom output formats with custom extensions, for example `datasette-atom <https://github.com/simonw/datasette-atom>`__ and
  `datasette-ics <https://github.com/simonw/datasette-ics>`__.
* Add template functions that can be called within your Jinja custom templates,
  for example `datasette-render-markdown <https://github.com/simonw/datasette-render-markdown#markdown-in-templates>`__.
* Customize how database values are rendered in the Datasette interface, for example
  `datasette-render-binary <https://github.com/simonw/datasette-render-binary>`__ and
  `datasette-pretty-json <https://github.com/simonw/datasette-pretty-json>`__.
* Customize how Datasette's authentication and permissions systems work, for example `datasette-auth-passwords <https://github.com/simonw/datasette-auth-passwords>`__ and
  `datasette-permissions-sql <https://github.com/simonw/datasette-permissions-sql>`__.

.. _plugins_installing:

Installing plugins
------------------

If a plugin has been packaged for distribution using setuptools you can use the plugin by installing it alongside Datasette in the same virtual environment or Docker container.

You can install plugins using the ``datasette install`` command::

    datasette install datasette-vega

You can uninstall plugins with ``datasette uninstall``::

    datasette uninstall datasette-vega

You can upgrade plugins with ``datasette install --upgrade`` or ``datasette install -U``::

    datasette install -U datasette-vega

This command can also be used to upgrade Datasette itself to the latest released version::

    datasette install -U datasette

You can install multiple plugins at once by listing them as lines in a ``requirements.txt`` file like this::

    datasette-vega
    datasette-cluster-map

Then pass that file to ``datasette install -r``::

    datasette install -r requirements.txt

The ``install`` and ``uninstall`` commands are thin wrappers around ``pip install`` and ``pip uninstall``, which ensure that they run ``pip`` in the same virtual environment as Datasette itself.

One-off plugins using --plugins-dir
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can also define one-off per-project plugins by saving them as ``plugin_name.py`` functions in a ``plugins/`` folder and then passing that folder to ``datasette`` using the ``--plugins-dir`` option::

    datasette mydb.db --plugins-dir=plugins/

Deploying plugins using datasette publish
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``datasette publish`` and ``datasette package`` commands both take an optional ``--install`` argument. You can use this one or more times to tell Datasette to ``pip install`` specific plugins as part of the process::

    datasette publish cloudrun mydb.db --install=datasette-vega

You can use the name of a package on PyPI or any of the other valid arguments to ``pip install`` such as a URL to a ``.zip`` file::

    datasette publish cloudrun mydb.db \
        --install=https://url-to-my-package.zip


.. _plugins_datasette_load_plugins:

Controlling which plugins are loaded
------------------------------------

Datasette defaults to loading every plugin that is installed in the same virtual environment as Datasette itself.

You can set the ``DATASETTE_LOAD_PLUGINS`` environment variable to a comma-separated list of plugin names to load a controlled subset of plugins instead.

For example, to load just the ``datasette-vega`` and ``datasette-cluster-map`` plugins, set ``DATASETTE_LOAD_PLUGINS`` to ``datasette-vega,datasette-cluster-map``:

.. code-block:: bash

    export DATASETTE_LOAD_PLUGINS='datasette-vega,datasette-cluster-map'
    datasette mydb.db

Or:

.. code-block:: bash

    DATASETTE_LOAD_PLUGINS='datasette-vega,datasette-cluster-map' \
      datasette mydb.db

To disable the loading of all additional plugins, set ``DATASETTE_LOAD_PLUGINS`` to an empty string:

.. code-block:: bash

    export DATASETTE_LOAD_PLUGINS=''
    datasette mydb.db

A quick way to test this setting is to use it with the ``datasette plugins`` command:

.. code-block:: bash

    DATASETTE_LOAD_PLUGINS='datasette-vega' datasette plugins

This should output the following:

.. code-block:: json

    [
        {
            "name": "datasette-vega",
            "static": true,
            "templates": false,
            "version": "0.6.2",
            "hooks": [
                "extra_css_urls",
                "extra_js_urls"
            ]
        }
    ]

.. _plugins_installed:

Seeing what plugins are installed
---------------------------------

You can see a list of installed plugins by navigating to the ``/-/plugins`` page of your Datasette instance - for example: https://fivethirtyeight.datasettes.com/-/plugins

You can also use the ``datasette plugins`` command::

    datasette plugins

Which outputs:

.. code-block:: json

    [
        {
            "name": "datasette_json_html",
            "static": false,
            "templates": false,
            "version": "0.4.0"
        }
    ]

.. [[[cog
    from datasette import cli
    from click.testing import CliRunner
    import textwrap, json
    cog.out("\n")
    result = CliRunner().invoke(cli.cli, ["plugins", "--all"])
    # cog.out() with text containing newlines was unindenting for some reason
    cog.outl("If you run ``datasette plugins --all`` it will include default plugins that ship as part of Datasette:\n")
    cog.outl(".. code-block:: json\n")
    plugins = [p for p in json.loads(result.output) if p["name"].startswith("datasette.")]
    indented = textwrap.indent(json.dumps(plugins, indent=4), "    ")
    for line in indented.split("\n"):
        cog.outl(line)
    cog.out("\n\n")
.. ]]]

If you run ``datasette plugins --all`` it will include default plugins that ship as part of Datasette:

.. code-block:: json

    [
        {
            "name": "datasette.actor_auth_cookie",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "actor_from_request"
            ]
        },
        {
            "name": "datasette.blob_renderer",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "register_output_renderer"
            ]
        },
        {
            "name": "datasette.default_magic_parameters",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "register_magic_parameters"
            ]
        },
        {
            "name": "datasette.default_menu_links",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "menu_links"
            ]
        },
        {
            "name": "datasette.default_permissions",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "actor_from_request",
                "permission_allowed",
                "register_permissions",
                "skip_csrf"
            ]
        },
        {
            "name": "datasette.events",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "register_events"
            ]
        },
        {
            "name": "datasette.facets",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "register_facet_classes"
            ]
        },
        {
            "name": "datasette.filters",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "filters_from_request"
            ]
        },
        {
            "name": "datasette.forbidden",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "forbidden"
            ]
        },
        {
            "name": "datasette.handle_exception",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "handle_exception"
            ]
        },
        {
            "name": "datasette.publish.cloudrun",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "publish_subcommand"
            ]
        },
        {
            "name": "datasette.publish.heroku",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "publish_subcommand"
            ]
        },
        {
            "name": "datasette.sql_functions",
            "static": false,
            "templates": false,
            "version": null,
            "hooks": [
                "prepare_connection"
            ]
        }
    ]


.. [[[end]]]

You can add the ``--plugins-dir=`` option to include any plugins found in that directory.

Add ``--requirements`` to output a list of installed plugins that can then be installed in another Datasette instance using ``datasette install -r requirements.txt``::

    datasette plugins --requirements

The output will look something like this::

    datasette-codespaces==0.1.1
    datasette-graphql==2.2
    datasette-json-html==1.0.1
    datasette-pretty-json==0.2.2
    datasette-x-forwarded-host==0.1

To write that to a ``requirements.txt`` file, run this::

    datasette plugins --requirements > requirements.txt

.. _plugins_configuration:

Plugin configuration
--------------------

Plugins can have their own configuration, embedded in a :ref:`configuration file <configuration>`. Configuration options for plugins live within a ``"plugins"`` key in that file, which can be included at the root, database or table level.

Here is an example of some plugin configuration for a specific table:

.. [[[cog
    from metadata_doc import config_example
    config_example(cog, {
        "databases": {
            "sf-trees": {
                "tables": {
                    "Street_Tree_List": {
                        "plugins": {
                            "datasette-cluster-map": {
                                "latitude_column": "lat",
                                "longitude_column": "lng"
                            }
                        }
                    }
                }
            }
        }
    })
.. ]]]

.. tab:: datasette.yaml

    .. code-block:: yaml

        databases:
          sf-trees:
            tables:
              Street_Tree_List:
                plugins:
                  datasette-cluster-map:
                    latitude_column: lat
                    longitude_column: lng


.. tab:: datasette.json

    .. code-block:: json

        {
          "databases": {
            "sf-trees": {
              "tables": {
                "Street_Tree_List": {
                  "plugins": {
                    "datasette-cluster-map": {
                      "latitude_column": "lat",
                      "longitude_column": "lng"
                    }
                  }
                }
              }
            }
          }
        }
.. [[[end]]]

This tells the ``datasette-cluster-map`` column which latitude and longitude columns should be used for a table called ``Street_Tree_List`` inside a database file called ``sf-trees.db``.

.. _plugins_configuration_secret:

Secret configuration values
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some plugins may need configuration that should stay secret - API keys for example. There are two ways in which you can store secret configuration values.

**As environment variables**. If your secret lives in an environment variable that is available to the Datasette process, you can indicate that the configuration value should be read from that environment variable like so:

.. [[[cog
    config_example(cog, {
        "plugins": {
            "datasette-auth-github": {
                "client_secret": {
                    "$env": "GITHUB_CLIENT_SECRET"
                }
            }
        }
    })
.. ]]]

.. tab:: datasette.yaml

    .. code-block:: yaml

        plugins:
          datasette-auth-github:
            client_secret:
              $env: GITHUB_CLIENT_SECRET


.. tab:: datasette.json

    .. code-block:: json

        {
          "plugins": {
            "datasette-auth-github": {
              "client_secret": {
                "$env": "GITHUB_CLIENT_SECRET"
              }
            }
          }
        }
.. [[[end]]]

**As values in separate files**. Your secrets can also live in files on disk. To specify a secret should be read from a file, provide the full file path like this:

.. [[[cog
    config_example(cog, {
        "plugins": {
            "datasette-auth-github": {
                "client_secret": {
                    "$file": "/secrets/client-secret"
                }
            }
        }
    })
.. ]]]

.. tab:: datasette.yaml

    .. code-block:: yaml

        plugins:
          datasette-auth-github:
            client_secret:
              $file: /secrets/client-secret


.. tab:: datasette.json

    .. code-block:: json

        {
          "plugins": {
            "datasette-auth-github": {
              "client_secret": {
                "$file": "/secrets/client-secret"
              }
            }
          }
        }
.. [[[end]]]

If you are publishing your data using the :ref:`datasette publish <cli_publish>` family of commands, you can use the ``--plugin-secret`` option to set these secrets at publish time. For example, using Heroku you might run the following command::

    datasette publish heroku my_database.db \
        --name my-heroku-app-demo \
        --install=datasette-auth-github \
        --plugin-secret datasette-auth-github client_id your_client_id \
        --plugin-secret datasette-auth-github client_secret your_client_secret

This will set the necessary environment variables and add the following to the deployed ``metadata.yaml``:

.. [[[cog
    config_example(cog, {
        "plugins": {
            "datasette-auth-github": {
                "client_id": {
                    "$env": "DATASETTE_AUTH_GITHUB_CLIENT_ID"
                },
                "client_secret": {
                    "$env": "DATASETTE_AUTH_GITHUB_CLIENT_SECRET"
                }
            }
        }
    })
.. ]]]

.. tab:: datasette.yaml

    .. code-block:: yaml

        plugins:
          datasette-auth-github:
            client_id:
              $env: DATASETTE_AUTH_GITHUB_CLIENT_ID
            client_secret:
              $env: DATASETTE_AUTH_GITHUB_CLIENT_SECRET


.. tab:: datasette.json

    .. code-block:: json

        {
          "plugins": {
            "datasette-auth-github": {
              "client_id": {
                "$env": "DATASETTE_AUTH_GITHUB_CLIENT_ID"
              },
              "client_secret": {
                "$env": "DATASETTE_AUTH_GITHUB_CLIENT_SECRET"
              }
            }
          }
        }
.. [[[end]]]

</document_content>
</document>
<document index="2">
<source>docs/plugin_hooks.rst</source>
<document_content>
.. _plugin_hooks:

Plugin hooks
============

Datasette :ref:`plugins <plugins>` use *plugin hooks* to customize Datasette's behavior. These hooks are powered by the `pluggy <https://pluggy.readthedocs.io/>`__ plugin system.

Each plugin can implement one or more hooks using the ``@hookimpl`` decorator against a function named that matches one of the hooks documented on this page.

When you implement a plugin hook you can accept any or all of the parameters that are documented as being passed to that hook.

For example, you can implement the ``render_cell`` plugin hook like this even though the full documented hook signature is ``render_cell(row, value, column, table, database, datasette)``:

.. code-block:: python

    @hookimpl
    def render_cell(value, column):
        if column == "stars":
            return "*" * int(value)

.. contents:: List of plugin hooks
   :local:
   :class: this-will-duplicate-information-and-it-is-still-useful-here

.. _plugin_hook_prepare_connection:

prepare_connection(conn, database, datasette)
---------------------------------------------

``conn`` - sqlite3 connection object
    The connection that is being opened

``database`` - string
    The name of the database

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``

This hook is called when a new SQLite database connection is created. You can
use it to `register custom SQL functions <https://docs.python.org/2/library/sqlite3.html#sqlite3.Connection.create_function>`_,
aggregates and collations. For example:

.. code-block:: python

    from datasette import hookimpl
    import random


    @hookimpl
    def prepare_connection(conn):
        conn.create_function(
            "random_integer", 2, random.randint
        )

This registers a SQL function called ``random_integer`` which takes two
arguments and can be called like this::

    select random_integer(1, 10);

Examples: `datasette-jellyfish <https://datasette.io/plugins/datasette-jellyfish>`__, `datasette-jq <https://datasette.io/plugins/datasette-jq>`__, `datasette-haversine <https://datasette.io/plugins/datasette-haversine>`__, `datasette-rure <https://datasette.io/plugins/datasette-rure>`__

.. _plugin_hook_prepare_jinja2_environment:

prepare_jinja2_environment(env, datasette)
------------------------------------------

``env`` - jinja2 Environment
    The template environment that is being prepared

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``

This hook is called with the Jinja2 environment that is used to evaluate
Datasette HTML templates. You can use it to do things like `register custom
template filters <http://jinja.pocoo.org/docs/2.10/api/#custom-filters>`_, for
example:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def prepare_jinja2_environment(env):
        env.filters["uppercase"] = lambda u: u.upper()

You can now use this filter in your custom templates like so::

    Table name: {{ table|uppercase }}

This function can return an awaitable function if it needs to run any async code.

Examples: `datasette-edit-templates <https://datasette.io/plugins/datasette-edit-templates>`_

.. _plugin_page_extras:

Page extras
-----------

These plugin hooks can be used to affect the way HTML pages for different Datasette interfaces are rendered.

.. _plugin_hook_extra_template_vars:

extra_template_vars(template, database, table, columns, view_name, request, datasette)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Extra template variables that should be made available in the rendered template context.

``template`` - string
    The template that is being rendered, e.g. ``database.html``

``database`` - string or None
    The name of the database, or ``None`` if the page does not correspond to a database (e.g. the root page)

``table`` - string or None
    The name of the table, or ``None`` if the page does not correct to a table

``columns`` - list of strings or None
    The names of the database columns that will be displayed on this page. ``None`` if the page does not contain a table.

``view_name`` - string
    The name of the view being displayed. (``index``, ``database``, ``table``, and ``row`` are the most important ones.)

``request`` - :ref:`internals_request` or None
    The current HTTP request. This can be ``None`` if the request object is not available.

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``

This hook can return one of three different types:

Dictionary
    If you return a dictionary its keys and values will be merged into the template context.

Function that returns a dictionary
    If you return a function it will be executed. If it returns a dictionary those values will will be merged into the template context.

Function that returns an awaitable function that returns a dictionary
    You can also return a function which returns an awaitable function which returns a dictionary.

Datasette runs Jinja2 in `async mode <https://jinja.palletsprojects.com/en/2.10.x/api/#async-support>`__, which means you can add awaitable functions to the template scope and they will be automatically awaited when they are rendered by the template.

Here's an example plugin that adds a ``"user_agent"`` variable to the template context containing the current request's User-Agent header:

.. code-block:: python

    @hookimpl
    def extra_template_vars(request):
        return {"user_agent": request.headers.get("user-agent")}

This example returns an awaitable function which adds a list of ``hidden_table_names`` to the context:

.. code-block:: python

    @hookimpl
    def extra_template_vars(datasette, database):
        async def hidden_table_names():
            if database:
                db = datasette.databases[database]
                return {
                    "hidden_table_names": await db.hidden_table_names()
                }
            else:
                return {}

        return hidden_table_names

And here's an example which adds a ``sql_first(sql_query)`` function which executes a SQL statement and returns the first column of the first row of results:

.. code-block:: python

    @hookimpl
    def extra_template_vars(datasette, database):
        async def sql_first(sql, dbname=None):
            dbname = (
                dbname
                or database
                or next(iter(datasette.databases.keys()))
            )
            result = await datasette.execute(dbname, sql)
            return result.rows[0][0]

        return {"sql_first": sql_first}

You can then use the new function in a template like so::

    SQLite version: {{ sql_first("select sqlite_version()") }}

Examples: `datasette-search-all <https://datasette.io/plugins/datasette-search-all>`_, `datasette-template-sql <https://datasette.io/plugins/datasette-template-sql>`_

.. _plugin_hook_extra_css_urls:

extra_css_urls(template, database, table, columns, view_name, request, datasette)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This takes the same arguments as :ref:`extra_template_vars(...) <plugin_hook_extra_template_vars>`

Return a list of extra CSS URLs that should be included on the page. These can
take advantage of the CSS class hooks described in :ref:`customization`.

This can be a list of URLs:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def extra_css_urls():
        return [
            "https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css"
        ]

Or a list of dictionaries defining both a URL and an
`SRI hash <https://www.srihash.org/>`_:

.. code-block:: python

    @hookimpl
    def extra_css_urls():
        return [
            {
                "url": "https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css",
                "sri": "sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4",
            }
        ]

This function can also return an awaitable function, useful if it needs to run any async code:

.. code-block:: python

    @hookimpl
    def extra_css_urls(datasette):
        async def inner():
            db = datasette.get_database()
            results = await db.execute(
                "select url from css_files"
            )
            return [r[0] for r in results]

        return inner

Examples: `datasette-cluster-map <https://datasette.io/plugins/datasette-cluster-map>`_, `datasette-vega <https://datasette.io/plugins/datasette-vega>`_

.. _plugin_hook_extra_js_urls:

extra_js_urls(template, database, table, columns, view_name, request, datasette)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This takes the same arguments as :ref:`extra_template_vars(...) <plugin_hook_extra_template_vars>`

This works in the same way as ``extra_css_urls()`` but for JavaScript. You can
return a list of URLs, a list of dictionaries or an awaitable function that returns those things:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def extra_js_urls():
        return [
            {
                "url": "https://code.jquery.com/jquery-3.3.1.slim.min.js",
                "sri": "sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo",
            }
        ]

You can also return URLs to files from your plugin's ``static/`` directory, if
you have one:

.. code-block:: python

    @hookimpl
    def extra_js_urls():
        return ["/-/static-plugins/your-plugin/app.js"]

Note that ``your-plugin`` here should be the hyphenated plugin name - the name that is displayed in the list on the ``/-/plugins`` debug page.

If your code uses `JavaScript modules <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules>`__ you should include the ``"module": True`` key. See :ref:`configuration_reference_css_js` for more details.

.. code-block:: python

    @hookimpl
    def extra_js_urls():
        return [
            {
                "url": "/-/static-plugins/your-plugin/app.js",
                "module": True,
            }
        ]

Examples: `datasette-cluster-map <https://datasette.io/plugins/datasette-cluster-map>`_, `datasette-vega <https://datasette.io/plugins/datasette-vega>`_

.. _plugin_hook_extra_body_script:

extra_body_script(template, database, table, columns, view_name, request, datasette)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Extra JavaScript to be added to a ``<script>`` block at the end of the ``<body>`` element on the page.

This takes the same arguments as :ref:`extra_template_vars(...) <plugin_hook_extra_template_vars>`

The ``template``, ``database``, ``table`` and ``view_name`` options can be used to return different code depending on which template is being rendered and which database or table are being processed.

The ``datasette`` instance is provided primarily so that you can consult any plugin configuration options that may have been set, using the ``datasette.plugin_config(plugin_name)`` method documented above.

This function can return a string containing JavaScript, or a dictionary as described below, or a function or awaitable function that returns a string or dictionary.

Use a dictionary if you want to specify that the code should be placed in a ``<script type="module">...</script>`` element:

.. code-block:: python

    @hookimpl
    def extra_body_script():
        return {
            "module": True,
            "script": "console.log('Your JavaScript goes here...')",
        }

This will add the following to the end of your page:

.. code-block:: html

    <script type="module">console.log('Your JavaScript goes here...')</script>

Example: `datasette-cluster-map <https://datasette.io/plugins/datasette-cluster-map>`_

.. _plugin_hook_publish_subcommand:

publish_subcommand(publish)
---------------------------

``publish`` - Click publish command group
    The Click command group for the ``datasette publish`` subcommand

This hook allows you to create new providers for the ``datasette publish``
command. Datasette uses this hook internally to implement the default ``cloudrun``
and ``heroku`` subcommands, so you can read
`their source <https://github.com/simonw/datasette/tree/main/datasette/publish>`_
to see examples of this hook in action.

Let's say you want to build a plugin that adds a ``datasette publish my_hosting_provider --api_key=xxx mydatabase.db`` publish command. Your implementation would start like this:

.. code-block:: python

    from datasette import hookimpl
    from datasette.publish.common import (
        add_common_publish_arguments_and_options,
    )
    import click


    @hookimpl
    def publish_subcommand(publish):
        @publish.command()
        @add_common_publish_arguments_and_options
        @click.option(
            "-k",
            "--api_key",
            help="API key for talking to my hosting provider",
        )
        def my_hosting_provider(
            files,
            metadata,
            extra_options,
            branch,
            template_dir,
            plugins_dir,
            static,
            install,
            plugin_secret,
            version_note,
            secret,
            title,
            license,
            license_url,
            source,
            source_url,
            about,
            about_url,
            api_key,
        ): ...

Examples: `datasette-publish-fly <https://datasette.io/plugins/datasette-publish-fly>`_, `datasette-publish-vercel <https://datasette.io/plugins/datasette-publish-vercel>`_

.. _plugin_hook_render_cell:

render_cell(row, value, column, table, database, datasette, request)
--------------------------------------------------------------------

Lets you customize the display of values within table cells in the HTML table view.

``row`` - ``sqlite.Row``
    The SQLite row object that the value being rendered is part of

``value`` - string, integer, float, bytes or None
    The value that was loaded from the database

``column`` - string
    The name of the column being rendered

``table`` - string or None
    The name of the table - or ``None`` if this is a custom SQL query

``database`` - string
    The name of the database

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``request`` - :ref:`internals_request`
    The current request object

If your hook returns ``None``, it will be ignored. Use this to indicate that your hook is not able to custom render this particular value.

If the hook returns a string, that string will be rendered in the table cell.

If you want to return HTML markup you can do so by returning a ``jinja2.Markup`` object.

You can also return an awaitable function which returns a value.

Datasette will loop through all available ``render_cell`` hooks and display the value returned by the first one that does not return ``None``.

Here is an example of a custom ``render_cell()`` plugin which looks for values that are a JSON string matching the following format::

    {"href": "https://www.example.com/", "label": "Name"}

If the value matches that pattern, the plugin returns an HTML link element:

.. code-block:: python

    from datasette import hookimpl
    import markupsafe
    import json


    @hookimpl
    def render_cell(value):
        # Render {"href": "...", "label": "..."} as link
        if not isinstance(value, str):
            return None
        stripped = value.strip()
        if not (
            stripped.startswith("{") and stripped.endswith("}")
        ):
            return None
        try:
            data = json.loads(value)
        except ValueError:
            return None
        if not isinstance(data, dict):
            return None
        if set(data.keys()) != {"href", "label"}:
            return None
        href = data["href"]
        if not (
            href.startswith("/")
            or href.startswith("http://")
            or href.startswith("https://")
        ):
            return None
        return markupsafe.Markup(
            '<a href="{href}">{label}</a>'.format(
                href=markupsafe.escape(data["href"]),
                label=markupsafe.escape(data["label"] or "")
                or "&nbsp;",
            )
        )

Examples: `datasette-render-binary <https://datasette.io/plugins/datasette-render-binary>`_, `datasette-render-markdown <https://datasette.io/plugins/datasette-render-markdown>`__, `datasette-json-html <https://datasette.io/plugins/datasette-json-html>`__

.. _plugin_register_output_renderer:

register_output_renderer(datasette)
-----------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``

Registers a new output renderer, to output data in a custom format. The hook function should return a dictionary, or a list of dictionaries, of the following shape:

.. code-block:: python

    @hookimpl
    def register_output_renderer(datasette):
        return {
            "extension": "test",
            "render": render_demo,
            "can_render": can_render_demo,  # Optional
        }

This will register ``render_demo`` to be called when paths with the extension ``.test`` (for example ``/database.test``, ``/database/table.test``, or ``/database/table/row.test``) are requested.

``render_demo`` is a Python function. It can be a regular function or an ``async def render_demo()`` awaitable function, depending on if it needs to make any asynchronous calls.

``can_render_demo`` is a Python function (or ``async def`` function) which accepts the same arguments as ``render_demo`` but just returns ``True`` or ``False``. It lets Datasette know if the current SQL query can be represented by the plugin - and hence influence if a link to this output format is displayed in the user interface. If you omit the ``"can_render"`` key from the dictionary every query will be treated as being supported by the plugin.

When a request is received, the ``"render"`` callback function is called with zero or more of the following arguments. Datasette will inspect your callback function and pass arguments that match its function signature.

``datasette`` - :ref:`internals_datasette`
    For accessing plugin configuration and executing queries.

``columns`` - list of strings
    The names of the columns returned by this query.

``rows`` - list of ``sqlite3.Row`` objects
    The rows returned by the query.

``sql`` - string
    The SQL query that was executed.

``query_name`` - string or None
    If this was the execution of a :ref:`canned query <canned_queries>`, the name of that query.

``database`` - string
    The name of the database.

``table`` - string or None
    The table or view, if one is being rendered.

``request`` - :ref:`internals_request`
    The current HTTP request.

``error`` - string or None
    If an error occurred this string will contain the error message.

``truncated`` - bool or None
    If the query response was truncated - for example a SQL query returning more than 1,000 results where pagination is not available - this will be ``True``.

``view_name`` - string
    The name of the current view being called. ``index``, ``database``, ``table``, and ``row`` are the most important ones.

The callback function can return ``None``, if it is unable to render the data, or a :ref:`internals_response` that will be returned to the caller.

It can also return a dictionary with the following keys. This format is **deprecated** as-of Datasette 0.49 and will be removed by Datasette 1.0.

``body`` - string or bytes, optional
    The response body, default empty

``content_type`` - string, optional
    The Content-Type header, default ``text/plain``

``status_code`` - integer, optional
    The HTTP status code, default 200

``headers`` - dictionary, optional
    Extra HTTP headers to be returned in the response.

An example of an output renderer callback function:

.. code-block:: python

    def render_demo():
        return Response.text("Hello World")

Here is a more complex example:

.. code-block:: python

    async def render_demo(datasette, columns, rows):
        db = datasette.get_database()
        result = await db.execute("select sqlite_version()")
        first_row = " | ".join(columns)
        lines = [first_row]
        lines.append("=" * len(first_row))
        for row in rows:
            lines.append(" | ".join(row))
        return Response(
            "\n".join(lines),
            content_type="text/plain; charset=utf-8",
            headers={"x-sqlite-version": result.first()[0]},
        )

And here is an example ``can_render`` function which returns ``True`` only if the query results contain the columns ``atom_id``, ``atom_title`` and ``atom_updated``:

.. code-block:: python

    def can_render_demo(columns):
        return {
            "atom_id",
            "atom_title",
            "atom_updated",
        }.issubset(columns)

Examples: `datasette-atom <https://datasette.io/plugins/datasette-atom>`_, `datasette-ics <https://datasette.io/plugins/datasette-ics>`_, `datasette-geojson <https://datasette.io/plugins/datasette-geojson>`__, `datasette-copyable <https://datasette.io/plugins/datasette-copyable>`__

.. _plugin_register_routes:

register_routes(datasette)
--------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``

Register additional view functions to execute for specified URL routes.

Return a list of ``(regex, view_function)`` pairs, something like this:

.. code-block:: python

    from datasette import hookimpl, Response
    import html


    async def hello_from(request):
        name = request.url_vars["name"]
        return Response.html(
            "Hello from {}".format(html.escape(name))
        )


    @hookimpl
    def register_routes():
        return [(r"^/hello-from/(?P<name>.*)$", hello_from)]

The view functions can take a number of different optional arguments. The corresponding argument will be passed to your function depending on its named parameters - a form of dependency injection.

The optional view function arguments are as follows:

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``request`` - :ref:`internals_request`
    The current HTTP request.

``scope`` - dictionary
    The incoming ASGI scope dictionary.

``send`` - function
    The ASGI send function.

``receive`` - function
    The ASGI receive function.

The view function can be a regular function or an ``async def`` function, depending on if it needs to use any ``await`` APIs.

The function can either return a :ref:`internals_response` or it can return nothing and instead respond directly to the request using the ASGI ``send`` function (for advanced uses only).

It can also raise the ``datasette.NotFound`` exception to return a 404 not found error, or the ``datasette.Forbidden`` exception for a 403 forbidden.

See :ref:`writing_plugins_designing_urls` for tips on designing the URL routes used by your plugin.

Examples: `datasette-auth-github <https://datasette.io/plugins/datasette-auth-github>`__, `datasette-psutil <https://datasette.io/plugins/datasette-psutil>`__

.. _plugin_hook_register_commands:

register_commands(cli)
----------------------

``cli`` - the root Datasette `Click command group <https://click.palletsprojects.com/en/latest/commands/#callback-invocation>`__
    Use this to register additional CLI commands

Register additional CLI commands that can be run using ``datsette yourcommand ...``. This provides a mechanism by which plugins can add new CLI commands to Datasette.

This example registers a new ``datasette verify file1.db file2.db`` command that checks if the provided file paths are valid SQLite databases:

.. code-block:: python

    from datasette import hookimpl
    import click
    import sqlite3


    @hookimpl
    def register_commands(cli):
        @cli.command()
        @click.argument(
            "files", type=click.Path(exists=True), nargs=-1
        )
        def verify(files):
            "Verify that files can be opened by Datasette"
            for file in files:
                conn = sqlite3.connect(str(file))
                try:
                    conn.execute("select * from sqlite_master")
                except sqlite3.DatabaseError:
                    raise click.ClickException(
                        "Invalid database: {}".format(file)
                    )

The new command can then be executed like so::

    datasette verify fixtures.db

Help text (from the docstring for the function plus any defined Click arguments or options) will become available using::

    datasette verify --help

Plugins can register multiple commands by making multiple calls to the ``@cli.command()`` decorator. Consult the `Click documentation <https://click.palletsprojects.com/>`__ for full details on how to build a CLI command, including how to define arguments and options.

Note that ``register_commands()`` plugins cannot used with the :ref:`--plugins-dir mechanism <writing_plugins_one_off>` - they need to be installed into the same virtual environment as Datasette using ``pip install``. Provided it has a ``setup.py`` file (see :ref:`writing_plugins_packaging`) you can run ``pip install`` directly against the directory in which you are developing your plugin like so::

    pip install -e path/to/my/datasette-plugin

Examples: `datasette-auth-passwords <https://datasette.io/plugins/datasette-auth-passwords>`__, `datasette-verify <https://datasette.io/plugins/datasette-verify>`__

.. _plugin_register_facet_classes:

register_facet_classes()
------------------------

Return a list of additional Facet subclasses to be registered.

.. warning::
    The design of this plugin hook is unstable and may change. See `issue 830 <https://github.com/simonw/datasette/issues/830>`__.

Each Facet subclass implements a new type of facet operation. The class should look like this:

.. code-block:: python

    class SpecialFacet(Facet):
        # This key must be unique across all facet classes:
        type = "special"

        async def suggest(self):
            # Use self.sql and self.params to suggest some facets
            suggested_facets = []
            suggested_facets.append(
                {
                    "name": column,  # Or other unique name
                    # Construct the URL that will enable this facet:
                    "toggle_url": self.ds.absolute_url(
                        self.request,
                        path_with_added_args(
                            self.request, {"_facet": column}
                        ),
                    ),
                }
            )
            return suggested_facets

        async def facet_results(self):
            # This should execute the facet operation and return results, again
            # using self.sql and self.params as the starting point
            facet_results = []
            facets_timed_out = []
            facet_size = self.get_facet_size()
            # Do some calculations here...
            for column in columns_selected_for_facet:
                try:
                    facet_results_values = []
                    # More calculations...
                    facet_results_values.append(
                        {
                            "value": value,
                            "label": label,
                            "count": count,
                            "toggle_url": self.ds.absolute_url(
                                self.request, toggle_path
                            ),
                            "selected": selected,
                        }
                    )
                    facet_results.append(
                        {
                            "name": column,
                            "results": facet_results_values,
                            "truncated": len(facet_rows_results)
                            > facet_size,
                        }
                    )
                except QueryInterrupted:
                    facets_timed_out.append(column)

            return facet_results, facets_timed_out

See `datasette/facets.py <https://github.com/simonw/datasette/blob/main/datasette/facets.py>`__ for examples of how these classes can work.

The plugin hook can then be used to register the new facet class like this:

.. code-block:: python

    @hookimpl
    def register_facet_classes():
        return [SpecialFacet]

.. _plugin_register_permissions:

register_permissions(datasette)
--------------------------------

If your plugin needs to register additional permissions unique to that plugin - ``upload-csvs`` for example - you can return a list of those permissions from this hook.

.. code-block:: python

    from datasette import hookimpl, Permission


    @hookimpl
    def register_permissions(datasette):
        return [
            Permission(
                name="upload-csvs",
                abbr=None,
                description="Upload CSV files",
                takes_database=True,
                takes_resource=False,
                default=False,
            )
        ]

The fields of the ``Permission`` class are as follows:

``name`` - string
    The name of the permission, e.g. ``upload-csvs``. This should be unique across all plugins that the user might have installed, so choose carefully.

``abbr`` - string or None
    An abbreviation of the permission, e.g. ``uc``. This is optional - you can set it to ``None`` if you do not want to pick an abbreviation. Since this needs to be unique across all installed plugins it's best not to specify an abbreviation at all. If an abbreviation is provided it will be used when creating restricted signed API tokens.

``description`` - string or None
    A human-readable description of what the permission lets you do. Should make sense as the second part of a sentence that starts "A user with this permission can ...".

``takes_database`` - boolean
    ``True`` if this permission can be granted on a per-database basis, ``False`` if it is only valid at the overall Datasette instance level.

``takes_resource`` - boolean
    ``True`` if this permission can be granted on a per-resource basis. A resource is a database table, SQL view or :ref:`canned query <canned_queries>`.

``default`` - boolean
    The default value for this permission if it is not explicitly granted to a user. ``True`` means the permission is granted by default, ``False`` means it is not.

    This should only be ``True`` if you want anonymous users to be able to take this action.

.. _plugin_asgi_wrapper:

asgi_wrapper(datasette)
-----------------------

Return an `ASGI <https://asgi.readthedocs.io/>`__ middleware wrapper function that will be applied to the Datasette ASGI application.

This is a very powerful hook. You can use it to manipulate the entire Datasette response, or even to configure new URL routes that will be handled by your own custom code.

You can write your ASGI code directly against the low-level specification, or you can use the middleware utilities provided by an ASGI framework such as `Starlette <https://www.starlette.io/middleware/>`__.

This example plugin adds a ``x-databases`` HTTP header listing the currently attached databases:

.. code-block:: python

    from datasette import hookimpl
    from functools import wraps


    @hookimpl
    def asgi_wrapper(datasette):
        def wrap_with_databases_header(app):
            @wraps(app)
            async def add_x_databases_header(
                scope, receive, send
            ):
                async def wrapped_send(event):
                    if event["type"] == "http.response.start":
                        original_headers = (
                            event.get("headers") or []
                        )
                        event = {
                            "type": event["type"],
                            "status": event["status"],
                            "headers": original_headers
                            + [
                                [
                                    b"x-databases",
                                    ", ".join(
                                        datasette.databases.keys()
                                    ).encode("utf-8"),
                                ]
                            ],
                        }
                    await send(event)

                await app(scope, receive, wrapped_send)

            return add_x_databases_header

        return wrap_with_databases_header

Examples: `datasette-cors <https://datasette.io/plugins/datasette-cors>`__, `datasette-pyinstrument <https://datasette.io/plugins/datasette-pyinstrument>`__, `datasette-total-page-time <https://datasette.io/plugins/datasette-total-page-time>`__

.. _plugin_hook_startup:

startup(datasette)
------------------

This hook fires when the Datasette application server first starts up.

Here is an example that validates required plugin configuration. The server will fail to start and show an error if the validation check fails:

.. code-block:: python

    @hookimpl
    def startup(datasette):
        config = datasette.plugin_config("my-plugin") or {}
        assert (
            "required-setting" in config
        ), "my-plugin requires setting required-setting"

You can also return an async function, which will be awaited on startup. Use this option if you need to execute any database queries, for example this function which creates the ``my_table`` database table if it does not yet exist:

.. code-block:: python

    @hookimpl
    def startup(datasette):
        async def inner():
            db = datasette.get_database()
            if "my_table" not in await db.table_names():
                await db.execute_write(
                    """
                    create table my_table (mycol text)
                """
                )

        return inner

Potential use-cases:

* Run some initialization code for the plugin
* Create database tables that a plugin needs on startup
* Validate the configuration for a plugin on startup, and raise an error if it is invalid

.. note::

   If you are writing :ref:`unit tests <testing_plugins>` for a plugin that uses this hook and doesn't exercise Datasette by sending
   any simulated requests through it you will need to explicitly call ``await ds.invoke_startup()`` in your tests. An example:

   .. code-block:: python

        @pytest.mark.asyncio
        async def test_my_plugin():
            ds = Datasette()
            await ds.invoke_startup()
            # Rest of test goes here

Examples: `datasette-saved-queries <https://datasette.io/plugins/datasette-saved-queries>`__, `datasette-init <https://datasette.io/plugins/datasette-init>`__

.. _plugin_hook_canned_queries:

canned_queries(datasette, database, actor)
------------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``database`` - string
    The name of the database.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

Use this hook to return a dictionary of additional :ref:`canned query <canned_queries>` definitions for the specified database. The return value should be the same shape as the JSON described in the :ref:`canned query <canned_queries>` documentation.

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def canned_queries(datasette, database):
        if database == "mydb":
            return {
                "my_query": {
                    "sql": "select * from my_table where id > :min_id"
                }
            }

The hook can alternatively return an awaitable function that returns a list. Here's an example that returns queries that have been stored in the ``saved_queries`` database table, if one exists:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def canned_queries(datasette, database):
        async def inner():
            db = datasette.get_database(database)
            if await db.table_exists("saved_queries"):
                results = await db.execute(
                    "select name, sql from saved_queries"
                )
                return {
                    result["name"]: {"sql": result["sql"]}
                    for result in results
                }

        return inner

The actor parameter can be used to include the currently authenticated actor in your decision. Here's an example that returns saved queries that were saved by that actor:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def canned_queries(datasette, database, actor):
        async def inner():
            db = datasette.get_database(database)
            if actor is not None and await db.table_exists(
                "saved_queries"
            ):
                results = await db.execute(
                    "select name, sql from saved_queries where actor_id = :id",
                    {"id": actor["id"]},
                )
                return {
                    result["name"]: {"sql": result["sql"]}
                    for result in results
                }

        return inner

Example: `datasette-saved-queries <https://datasette.io/plugins/datasette-saved-queries>`__

.. _plugin_hook_actor_from_request:

actor_from_request(datasette, request)
--------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``request`` - :ref:`internals_request`
    The current HTTP request.

This is part of Datasette's :ref:`authentication and permissions system <authentication>`. The function should attempt to authenticate an actor (either a user or an API actor of some sort) based on information in the request.

If it cannot authenticate an actor, it should return ``None``. Otherwise it should return a dictionary representing that actor.

Here's an example that authenticates the actor based on an incoming API key:

.. code-block:: python

    from datasette import hookimpl
    import secrets

    SECRET_KEY = "this-is-a-secret"


    @hookimpl
    def actor_from_request(datasette, request):
        authorization = (
            request.headers.get("authorization") or ""
        )
        expected = "Bearer {}".format(SECRET_KEY)

        if secrets.compare_digest(authorization, expected):
            return {"id": "bot"}

If you install this in your plugins directory you can test it like this::

    curl -H 'Authorization: Bearer this-is-a-secret' http://localhost:8003/-/actor.json

Instead of returning a dictionary, this function can return an awaitable function which itself returns either ``None`` or a dictionary. This is useful for authentication functions that need to make a database query - for example:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def actor_from_request(datasette, request):
        async def inner():
            token = request.args.get("_token")
            if not token:
                return None
            # Look up ?_token=xxx in sessions table
            result = await datasette.get_database().execute(
                "select count(*) from sessions where token = ?",
                [token],
            )
            if result.first()[0]:
                return {"token": token}
            else:
                return None

        return inner

Examples: `datasette-auth-tokens <https://datasette.io/plugins/datasette-auth-tokens>`_, `datasette-auth-passwords <https://datasette.io/plugins/datasette-auth-passwords>`_

.. _plugin_hook_actors_from_ids:

actors_from_ids(datasette, actor_ids)
-------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor_ids`` - list of strings or integers
    The actor IDs to look up.

The hook must return a dictionary that maps the incoming actor IDs to their full dictionary representation.

Some plugins that implement social features may store the ID of the :ref:`actor <authentication_actor>` that performed an action - added a comment, bookmarked a table or similar - and then need a way to resolve those IDs into display-friendly actor dictionaries later on.

The :ref:`await datasette.actors_from_ids(actor_ids) <datasette_actors_from_ids>` internal method can be used to look up actors from their IDs. It will dispatch to the first plugin that implements this hook.

Unlike other plugin hooks, this only uses the first implementation of the hook to return a result. You can expect users to only have a single plugin installed that implements this hook.

If no plugin is installed, Datasette defaults to returning actors that are just ``{"id": actor_id}``.

The hook can return a dictionary or an awaitable function that then returns a dictionary.

This example implementation returns actors from a database table:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def actors_from_ids(datasette, actor_ids):
        db = datasette.get_database("actors")

        async def inner():
            sql = "select id, name from actors where id in ({})".format(
                ", ".join("?" for _ in actor_ids)
            )
            actors = {}
            for row in (await db.execute(sql, actor_ids)).rows:
                actor = dict(row)
                actors[actor["id"]] = actor
            return actors

        return inner

The returned dictionary from this example looks like this:

.. code-block:: json

    {
        "1": {"id": "1", "name": "Tony"},
        "2": {"id": "2", "name": "Tina"},
    }

These IDs could be integers or strings, depending on how the actors used by the Datasette instance are configured.

Example: `datasette-remote-actors <https://github.com/datasette/datasette-remote-actors>`_

.. _plugin_hook_jinja2_environment_from_request:

jinja2_environment_from_request(datasette, request, env)
--------------------------------------------------------

``datasette`` - :ref:`internals_datasette`
    A Datasette instance.

``request`` - :ref:`internals_request` or ``None``
    The current HTTP request, if one is available.

``env`` - ``Environment``
    The Jinja2 environment that will be used to render the current page.

This hook can be used to return a customized `Jinja environment <https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment>`__ based on the incoming request.

If you want to run a single Datasette instance that serves different content for different domains, you can do so like this:

.. code-block:: python

    from datasette import hookimpl
    from jinja2 import ChoiceLoader, FileSystemLoader


    @hookimpl
    def jinja2_environment_from_request(request, env):
        if request and request.host == "www.niche-museums.com":
            return env.overlay(
                loader=ChoiceLoader(
                    [
                        FileSystemLoader(
                            "/mnt/niche-museums/templates"
                        ),
                        env.loader,
                    ]
                ),
                enable_async=True,
            )
        return env

This uses the Jinja `overlay() method <https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment.overlay>`__ to create a new environment identical to the default environment except for having a different template loader, which first looks in the ``/mnt/niche-museums/templates`` directory before falling back on the default loader.

.. _plugin_hook_filters_from_request:

filters_from_request(request, database, table, datasette)
---------------------------------------------------------

``request`` - :ref:`internals_request`
    The current HTTP request.

``database`` - string
    The name of the database.

``table`` - string
    The name of the table.

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

This hook runs on the :ref:`table <TableView>` page, and can influence the ``where`` clause of the SQL query used to populate that page, based on query string arguments on the incoming request.

The hook should return an instance of ``datasette.filters.FilterArguments`` which has one required and three optional arguments:

.. code-block:: python

    return FilterArguments(
        where_clauses=["id > :max_id"],
        params={"max_id": 5},
        human_descriptions=["max_id is greater than 5"],
        extra_context={},
    )

The arguments to the ``FilterArguments`` class constructor are as follows:

``where_clauses`` - list of strings, required
    A list of SQL fragments that will be inserted into the SQL query, joined by the ``and`` operator. These can include ``:named`` parameters which will be populated using data in ``params``.
``params`` - dictionary, optional
    Additional keyword arguments to be used when the query is executed. These should match any ``:arguments`` in the where clauses.
``human_descriptions`` - list of strings, optional
    These strings will be included in the human-readable description at the top of the page and the page ``<title>``.
``extra_context`` - dictionary, optional
    Additional context variables that should be made available to the ``table.html`` template when it is rendered.

This example plugin causes 0 results to be returned if ``?_nothing=1`` is added to the URL:

.. code-block:: python

    from datasette import hookimpl
    from datasette.filters import FilterArguments


    @hookimpl
    def filters_from_request(self, request):
        if request.args.get("_nothing"):
            return FilterArguments(
                ["1 = 0"], human_descriptions=["NOTHING"]
            )

Example: `datasette-leaflet-freedraw <https://datasette.io/plugins/datasette-leaflet-freedraw>`_

.. _plugin_hook_permission_allowed:

permission_allowed(datasette, actor, action, resource)
------------------------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary
    The current actor, as decided by :ref:`plugin_hook_actor_from_request`.

``action`` - string
    The action to be performed, e.g. ``"edit-table"``.

``resource`` - string or None
    An identifier for the individual resource, e.g. the name of the table.

Called to check that an actor has permission to perform an action on a resource. Can return ``True`` if the action is allowed, ``False`` if the action is not allowed or ``None`` if the plugin does not have an opinion one way or the other.

Here's an example plugin which randomly selects if a permission should be allowed or denied, except for ``view-instance`` which always uses the default permission scheme instead.

.. code-block:: python

    from datasette import hookimpl
    import random


    @hookimpl
    def permission_allowed(action):
        if action != "view-instance":
            # Return True or False at random
            return random.random() > 0.5
        # Returning None falls back to default permissions

This function can alternatively return an awaitable function which itself returns ``True``, ``False`` or ``None``. You can use this option if you need to execute additional database queries using ``await datasette.execute(...)``.

Here's an example that allows users to view the ``admin_log`` table only if their actor ``id`` is present in the ``admin_users`` table. It aso disallows arbitrary SQL queries for the ``staff.db`` database for all users.

.. code-block:: python

    @hookimpl
    def permission_allowed(datasette, actor, action, resource):
        async def inner():
            if action == "execute-sql" and resource == "staff":
                return False
            if action == "view-table" and resource == (
                "staff",
                "admin_log",
            ):
                if not actor:
                    return False
                user_id = actor["id"]
                return await datasette.get_database(
                    "staff"
                ).execute(
                    "select count(*) from admin_users where user_id = :user_id",
                    {"user_id": user_id},
                )

        return inner

See :ref:`built-in permissions <permissions>` for a full list of permissions that are included in Datasette core.

Example: `datasette-permissions-sql <https://datasette.io/plugins/datasette-permissions-sql>`_

.. _plugin_hook_register_magic_parameters:

register_magic_parameters(datasette)
------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

:ref:`canned_queries_magic_parameters` can be used to add automatic parameters to :ref:`canned queries <canned_queries>`. This plugin hook allows additional magic parameters to be defined by plugins.

Magic parameters all take this format: ``_prefix_rest_of_parameter``. The prefix indicates which magic parameter function should be called - the rest of the parameter is passed as an argument to that function.

To register a new function, return it as a tuple of ``(string prefix, function)`` from this hook. The function you register should take two arguments: ``key`` and ``request``, where ``key`` is the ``rest_of_parameter`` portion of the parameter and ``request`` is the current :ref:`internals_request`.

This example registers two new magic parameters: ``:_request_http_version`` returning the HTTP version of the current request, and ``:_uuid_new`` which returns a new UUID. It also registers an ``:_asynclookup_key`` parameter, demonstrating that these functions can be asynchronous:

.. code-block:: python

    from datasette import hookimpl
    from uuid import uuid4


    def uuid(key, request):
        if key == "new":
            return str(uuid4())
        else:
            raise KeyError


    def request(key, request):
        if key == "http_version":
            return request.scope["http_version"]
        else:
            raise KeyError


    async def asynclookup(key, request):
        return await do_something_async(key)


    @hookimpl
    def register_magic_parameters(datasette):
        return [
            ("request", request),
            ("uuid", uuid),
            ("asynclookup", asynclookup),
        ]

.. _plugin_hook_forbidden:

forbidden(datasette, request, message)
--------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to render templates or execute SQL queries.

``request`` - :ref:`internals_request`
    The current HTTP request.

``message`` - string
    A message hinting at why the request was forbidden.

Plugins can use this to customize how Datasette responds when a 403 Forbidden error occurs - usually because a page failed a permission check, see :ref:`authentication_permissions`.

If a plugin hook wishes to react to the error, it should return a :ref:`Response object <internals_response>`.

This example returns a redirect to a ``/-/login`` page:

.. code-block:: python

    from datasette import hookimpl
    from urllib.parse import urlencode


    @hookimpl
    def forbidden(request, message):
        return Response.redirect(
            "/-/login?=" + urlencode({"message": message})
        )

The function can alternatively return an awaitable function if it needs to make any asynchronous method calls. This example renders a template:

.. code-block:: python

    from datasette import hookimpl, Response


    @hookimpl
    def forbidden(datasette):
        async def inner():
            return Response.html(
                await datasette.render_template(
                    "render_message.html", request=request
                )
            )

        return inner

.. _plugin_hook_handle_exception:

handle_exception(datasette, request, exception)
-----------------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to render templates or execute SQL queries.

``request`` - :ref:`internals_request`
    The current HTTP request.

``exception`` - ``Exception``
    The exception that was raised.

This hook is called any time an unexpected exception is raised. You can use it to record the exception.

If your handler returns a ``Response`` object it will be returned to the client in place of the default Datasette error page.

The handler can return a response directly, or it can return return an awaitable function that returns a response.

This example logs an error to `Sentry <https://sentry.io/>`__ and then renders a custom error page:

.. code-block:: python

    from datasette import hookimpl, Response
    import sentry_sdk


    @hookimpl
    def handle_exception(datasette, exception):
        sentry_sdk.capture_exception(exception)

        async def inner():
            return Response.html(
                await datasette.render_template(
                    "custom_error.html", request=request
                )
            )

        return inner

Example: `datasette-sentry <https://datasette.io/plugins/datasette-sentry>`_

.. _plugin_hook_skip_csrf:

skip_csrf(datasette, scope)
---------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``scope`` - dictionary
    The `ASGI scope <https://asgi.readthedocs.io/en/latest/specs/www.html#http-connection-scope>`__ for the incoming HTTP request.

This hook can be used to skip :ref:`internals_csrf` for a specific incoming request. For example, you might have a custom path at ``/submit-comment`` which is designed to accept comments from anywhere, whether or not the incoming request originated on the site and has an accompanying CSRF token.

This example will disable CSRF protection for that specific URL path:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def skip_csrf(scope):
        return scope["path"] == "/submit-comment"

If any of the currently active ``skip_csrf()`` plugin hooks return ``True``, CSRF protection will be skipped for the request.

.. _plugin_hook_menu_links:

menu_links(datasette, actor, request)
-------------------------------------

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

``request`` - :ref:`internals_request` or None
    The current HTTP request. This can be ``None`` if the request object is not available.

This hook allows additional items to be included in the menu displayed by Datasette's top right menu icon.

The hook should return a list of ``{"href": "...", "label": "..."}`` menu items. These will be added to the menu.

It can alternatively return an ``async def`` awaitable function which returns a list of menu items.

This example adds a new menu item but only if the signed in user is ``"root"``:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def menu_links(datasette, actor):
        if actor and actor.get("id") == "root":
            return [
                {
                    "href": datasette.urls.path(
                        "/-/edit-schema"
                    ),
                    "label": "Edit schema",
                },
            ]

Using :ref:`internals_datasette_urls` here ensures that links in the menu will take the :ref:`setting_base_url` setting into account.

Examples: `datasette-search-all <https://datasette.io/plugins/datasette-search-all>`_, `datasette-graphql <https://datasette.io/plugins/datasette-graphql>`_

.. _plugin_actions:

Action hooks
------------

Action hooks can be used to add items to the action menus that appear at the top of different pages within Datasette. Unlike :ref:`menu_links() <plugin_hook_menu_links>`, actions which are displayed on every page, actions should only be relevant to the page the user is currently viewing.

Each of these hooks should return return a list of ``{"href": "...", "label": "..."}`` menu items, with optional ``"description": "..."`` keys describing each action in more detail.

They can alternatively return an ``async def`` awaitable function which, when called, returns a list of those menu items.

.. _plugin_hook_table_actions:

table_actions(datasette, actor, database, table, request)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

``database`` - string
    The name of the database.

``table`` - string
    The name of the table.

``request`` - :ref:`internals_request` or None
    The current HTTP request. This can be ``None`` if the request object is not available.

This example adds a new table action if the signed in user is ``"root"``:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def table_actions(datasette, actor, database, table):
        if actor and actor.get("id") == "root":
            return [
                {
                    "href": datasette.urls.path(
                        "/-/edit-schema/{}/{}".format(
                            database, table
                        )
                    ),
                    "label": "Edit schema for this table",
                    "description": "Add, remove, rename or alter columns for this table.",
                }
            ]

Example: `datasette-graphql <https://datasette.io/plugins/datasette-graphql>`_

.. _plugin_hook_view_actions:

view_actions(datasette, actor, database, view, request)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

``database`` - string
    The name of the database.

``view`` - string
    The name of the SQL view.

``request`` - :ref:`internals_request` or None
    The current HTTP request. This can be ``None`` if the request object is not available.

Like :ref:`plugin_hook_table_actions` but for SQL views.

.. _plugin_hook_query_actions:

query_actions(datasette, actor, database, query_name, request, sql, params)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

``database`` - string
    The name of the database.

``query_name`` - string or None
    The name of the canned query, or ``None`` if this is an arbitrary SQL query.

``request`` - :ref:`internals_request`
    The current HTTP request.

``sql`` - string
    The SQL query being executed

``params`` - dictionary
    The parameters passed to the SQL query, if any.

Populates a "Query actions" menu on the canned query and arbitrary SQL query pages.

This example adds a new query action linking to a page for explaining a query:

.. code-block:: python

    from datasette import hookimpl
    import urllib


    @hookimpl
    def query_actions(datasette, database, query_name, sql):
        # Don't explain an explain
        if sql.lower().startswith("explain"):
            return
        return [
            {
                "href": datasette.urls.database(database)
                + "?"
                + urllib.parse.urlencode(
                    {
                        "sql": "explain " + sql,
                    }
                ),
                "label": "Explain this query",
                "description": "Get a summary of how SQLite executes the query",
            },
        ]

Example: `datasette-create-view <https://datasette.io/plugins/datasette-create-view>`_

.. _plugin_hook_row_actions:

row_actions(datasette, actor, request, database, table, row)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

``request`` - :ref:`internals_request` or None
    The current HTTP request.

``database`` - string
    The name of the database.

``table`` - string
    The name of the table.

``row`` - ``sqlite.Row``
    The SQLite row object being displayed on the page.

Return links for the "Row actions" menu shown at the top of the row page.

This example displays the row in JSON plus some additional debug information if the user is signed in:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def row_actions(datasette, database, table, actor, row):
        if actor:
            return [
                {
                    "href": datasette.urls.instance(),
                    "label": f"Row details for {actor['id']}",
                    "description": json.dumps(
                        dict(row), default=repr
                    ),
                },
            ]

Example: `datasette-enrichments <https://datasette.io/plugins/datasette-enrichments>`_

.. _plugin_hook_database_actions:

database_actions(datasette, actor, database, request)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

``database`` - string
    The name of the database.

``request`` - :ref:`internals_request`
    The current HTTP request.

Populates an actions menu on the database page.

This example adds a new database action for creating a table, if the user has the ``edit-schema`` permission:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def database_actions(datasette, actor, database):
        async def inner():
            if not await datasette.permission_allowed(
                actor,
                "edit-schema",
                resource=database,
                default=False,
            ):
                return []
            return [
                {
                    "href": datasette.urls.path(
                        "/-/edit-schema/{}/-/create".format(
                            database
                        )
                    ),
                    "label": "Create a table",
                }
            ]

        return inner

Example: `datasette-graphql <https://datasette.io/plugins/datasette-graphql>`_, `datasette-edit-schema <https://datasette.io/plugins/datasette-edit-schema>`_

.. _plugin_hook_homepage_actions:

homepage_actions(datasette, actor, request)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``, or to execute SQL queries.

``actor`` - dictionary or None
    The currently authenticated :ref:`actor <authentication_actor>`.

``request`` - :ref:`internals_request`
    The current HTTP request.

Populates an actions menu on the top-level index homepage of the Datasette instance.

This example adds a link an imagined tool for editing the homepage, only for signed in users:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def homepage_actions(datasette, actor):
        if actor:
            return [
                {
                    "href": datasette.urls.path(
                        "/-/customize-homepage"
                    ),
                    "label": "Customize homepage",
                }
            ]

.. _plugin_hook_slots:

Template slots
--------------

The following set of plugin hooks can be used to return extra HTML content that will be inserted into the corresponding page, directly below the ``<h1>`` heading.

Multiple plugins can contribute content here. The order in which it is displayed can be controlled using Pluggy's `call time order options <https://pluggy.readthedocs.io/en/stable/#call-time-order>`__.

Each of these plugin hooks can return either a string or an awaitable function that returns a string.

.. _plugin_hook_top_homepage:

top_homepage(datasette, request)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

``request`` - :ref:`internals_request`
    The current HTTP request.

Returns HTML to be displayed at the top of the Datasette homepage.

.. _plugin_hook_top_database:

top_database(datasette, request, database)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

``request`` - :ref:`internals_request`
    The current HTTP request.

``database`` - string
    The name of the database.

Returns HTML to be displayed at the top of the database page.

.. _plugin_hook_top_table:

top_table(datasette, request, database, table)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

``request`` - :ref:`internals_request`
    The current HTTP request.

``database`` - string
    The name of the database.

``table`` - string
    The name of the table.

Returns HTML to be displayed at the top of the table page.

.. _plugin_hook_top_row:

top_row(datasette, request, database, table, row)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

``request`` - :ref:`internals_request`
    The current HTTP request.

``database`` - string
    The name of the database.

``table`` - string
    The name of the table.

``row`` - ``sqlite.Row``
    The SQLite row object being displayed.

Returns HTML to be displayed at the top of the row page.

.. _plugin_hook_top_query:

top_query(datasette, request, database, sql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

``request`` - :ref:`internals_request`
    The current HTTP request.

``database`` - string
    The name of the database.

``sql`` - string
    The SQL query.

Returns HTML to be displayed at the top of the query results page.

.. _plugin_hook_top_canned_query:

top_canned_query(datasette, request, database, query_name)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

``request`` - :ref:`internals_request`
    The current HTTP request.

``database`` - string
    The name of the database.

``query_name`` - string
    The name of the canned query.

Returns HTML to be displayed at the top of the canned query page.

.. _plugin_event_tracking:

Event tracking
--------------

Datasette includes an internal mechanism for tracking notable events. This can be used for analytics, but can also be used by plugins that want to listen out for when key events occur (such as a table being created) and take action in response.

Plugins can register to receive events using the ``track_event`` plugin hook.

They can also define their own events for other plugins to receive using the :ref:`register_events() plugin hook <plugin_hook_register_events>`, combined with calls to the :ref:`datasette.track_event() internal method <datasette_track_event>`.

.. _plugin_hook_track_event:

track_event(datasette, event)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

``event`` - ``Event``
    Information about the event, represented as an instance of a subclass of the ``Event`` base class.

This hook will be called any time an event is tracked by code that calls the :ref:`datasette.track_event(...) <datasette_track_event>` internal method.

The ``event`` object will always have the following properties:

- ``name``: a string representing the name of the event, for example ``logout`` or ``create-table``.
- ``actor``: a dictionary representing the actor that triggered the event, or ``None`` if the event was not triggered by an actor.
- ``created``: a ``datatime.datetime`` object in the ``timezone.utc`` timezone representing the time the event object was created.

Other properties on the event will be available depending on the type of event. You can also access those as a dictionary using ``event.properties()``.

The events fired by Datasette core are :ref:`documented here <events>`.

This example plugin logs details of all events to standard error:

.. code-block:: python

    from datasette import hookimpl
    import json
    import sys


    @hookimpl
    def track_event(event):
        name = event.name
        actor = event.actor
        properties = event.properties()
        msg = json.dumps(
            {
                "name": name,
                "actor": actor,
                "properties": properties,
            }
        )
        print(msg, file=sys.stderr, flush=True)

The function can also return an async function which will be awaited. This is useful for writing to a database.

This example logs events to a ``datasette_events`` table in a database called ``events``. It uses the :ref:`plugin_hook_startup` hook to create that table if it does not exist.

.. code-block:: python

    from datasette import hookimpl
    import json


    @hookimpl
    def startup(datasette):
        async def inner():
            db = datasette.get_database("events")
            await db.execute_write(
                """
                create table if not exists datasette_events (
                    id integer primary key,
                    event_type text,
                    created text,
                    actor text,
                    properties text
                )
            """
            )

        return inner


    @hookimpl
    def track_event(datasette, event):
        async def inner():
            db = datasette.get_database("events")
            properties = event.properties()
            await db.execute_write(
                """
                insert into datasette_events (event_type, created, actor, properties)
                values (?, strftime('%Y-%m-%d %H:%M:%S', 'now'), ?, ?)
            """,
                (
                    event.name,
                    json.dumps(event.actor),
                    json.dumps(properties),
                ),
            )

        return inner

Example: `datasette-events-db <https://datasette.io/plugins/datasette-events-db>`_

.. _plugin_hook_register_events:

register_events(datasette)
~~~~~~~~~~~~~~~~~~~~~~~~~~

``datasette`` - :ref:`internals_datasette`
    You can use this to access plugin configuration options via ``datasette.plugin_config(your_plugin_name)``.

This hook should return a list of ``Event`` subclasses that represent custom events that the plugin might send to the :ref:`datasette.track_event() <datasette_track_event>` method.

This example registers event subclasses for ``ban-user`` and ``unban-user`` events:

.. code-block:: python

    from dataclasses import dataclass
    from datasette import hookimpl, Event


    @dataclass
    class BanUserEvent(Event):
        name = "ban-user"
        user: dict


    @dataclass
    class UnbanUserEvent(Event):
        name = "unban-user"
        user: dict


    @hookimpl
    def register_events():
        return [BanUserEvent, UnbanUserEvent]

The plugin can then call ``datasette.track_event(...)`` to send a ``ban-user`` event:

.. code-block:: python

    await datasette.track_event(
        BanUserEvent(user={"id": 1, "username": "cleverbot"})
    )

</document_content>
</document>
<document index="3">
<source>docs/testing_plugins.rst</source>
<document_content>
.. _testing_plugins:

Testing plugins
===============

We recommend using `pytest <https://docs.pytest.org/>`__ to write automated tests for your plugins.

If you use the template described in :ref:`writing_plugins_cookiecutter` your plugin will start with a single test in your ``tests/`` directory that looks like this:

.. code-block:: python

    from datasette.app import Datasette
    import pytest


    @pytest.mark.asyncio
    async def test_plugin_is_installed():
        datasette = Datasette(memory=True)
        response = await datasette.client.get("/-/plugins.json")
        assert response.status_code == 200
        installed_plugins = {p["name"] for p in response.json()}
        assert (
            "datasette-plugin-template-demo"
            in installed_plugins
        )


This test uses the :ref:`internals_datasette_client` object to exercise a test instance of Datasette. ``datasette.client`` is a wrapper around the `HTTPX <https://www.python-httpx.org/>`__ Python library which can imitate HTTP requests using ASGI. This is the recommended way to write tests against a Datasette instance.

This test also uses the `pytest-asyncio <https://pypi.org/project/pytest-asyncio/>`__ package to add support for ``async def`` test functions running under pytest.

You can install these packages like so::

    pip install pytest pytest-asyncio

If you are building an installable package you can add them as test dependencies to your ``setup.py`` module like this:

.. code-block:: python

    setup(
        name="datasette-my-plugin",
        # ...
        extras_require={"test": ["pytest", "pytest-asyncio"]},
        tests_require=["datasette-my-plugin[test]"],
    )

You can then install the test dependencies like so::

    pip install -e '.[test]'

Then run the tests using pytest like so::

    pytest

.. _testing_plugins_datasette_test_instance:

Setting up a Datasette test instance
------------------------------------

The above example shows the easiest way to start writing tests against a Datasette instance:

.. code-block:: python

    from datasette.app import Datasette
    import pytest


    @pytest.mark.asyncio
    async def test_plugin_is_installed():
        datasette = Datasette(memory=True)
        response = await datasette.client.get("/-/plugins.json")
        assert response.status_code == 200

Creating a ``Datasette()`` instance like this as useful shortcut in tests, but there is one detail you need to be aware of. It's important to ensure that the async method ``.invoke_startup()`` is called on that instance. You can do that like this:

.. code-block:: python

    datasette = Datasette(memory=True)
    await datasette.invoke_startup()

This method registers any :ref:`plugin_hook_startup` or :ref:`plugin_hook_prepare_jinja2_environment` plugins that might themselves need to make async calls.

If you are using ``await datasette.client.get()`` and similar methods then you don't need to worry about this - Datasette automatically calls ``invoke_startup()`` the first time it handles a request.

.. _testing_datasette_client:

Using datasette.client in tests
-------------------------------

The :ref:`internals_datasette_client` mechanism is designed for use in tests. It provides access to a pre-configured `HTTPX async client <https://www.python-httpx.org/async/>`__ instance that can make GET, POST and other HTTP requests against a Datasette instance from inside a test.

A simple test looks like this:

.. literalinclude:: ../tests/test_docs.py
   :language: python
   :start-after: # -- start test_homepage --
   :end-before: # -- end test_homepage --

Or for a JSON API:

.. literalinclude:: ../tests/test_docs.py
   :language: python
   :start-after: # -- start test_actor_is_null --
   :end-before: # -- end test_actor_is_null --

To make requests as an authenticated actor, create a signed ``ds_cookie`` using the ``datasette.client.actor_cookie()`` helper function and pass it in ``cookies=`` like this:

.. literalinclude:: ../tests/test_docs.py
   :language: python
   :start-after: # -- start test_signed_cookie_actor --
   :end-before: # -- end test_signed_cookie_actor --

.. _testing_plugins_pdb:

Using pdb for errors thrown inside Datasette
--------------------------------------------

If an exception occurs within Datasette itself during a test, the response returned to your plugin will have a ``response.status_code`` value of 500.

You can add ``pdb=True`` to the ``Datasette`` constructor to drop into a Python debugger session inside your test run instead of getting back a 500 response code. This is equivalent to running the ``datasette`` command-line tool with the ``--pdb`` option.

Here's what that looks like in a test function:

.. code-block:: python

    def test_that_opens_the_debugger_or_errors():
        ds = Datasette([db_path], pdb=True)
        response = await ds.client.get("/")

If you use this pattern you will need to run ``pytest`` with the ``-s`` option to avoid capturing stdin/stdout in order to interact with the debugger prompt.

.. _testing_plugins_fixtures:

Using pytest fixtures
---------------------

`Pytest fixtures <https://docs.pytest.org/en/stable/fixture.html>`__ can be used to create initial testable objects which can then be used by multiple tests.

A common pattern for Datasette plugins is to create a fixture which sets up a temporary test database and wraps it in a Datasette instance.

Here's an example that uses the `sqlite-utils library <https://sqlite-utils.datasette.io/en/stable/python-api.html>`__ to populate a temporary test database. It also sets the title of that table using a simulated ``metadata.json`` configuration:

.. code-block:: python

    from datasette.app import Datasette
    import pytest
    import sqlite_utils


    @pytest.fixture(scope="session")
    def datasette(tmp_path_factory):
        db_directory = tmp_path_factory.mktemp("dbs")
        db_path = db_directory / "test.db"
        db = sqlite_utils.Database(db_path)
        db["dogs"].insert_all(
            [
                {"id": 1, "name": "Cleo", "age": 5},
                {"id": 2, "name": "Pancakes", "age": 4},
            ],
            pk="id",
        )
        datasette = Datasette(
            [db_path],
            metadata={
                "databases": {
                    "test": {
                        "tables": {
                            "dogs": {"title": "Some dogs"}
                        }
                    }
                }
            },
        )
        return datasette


    @pytest.mark.asyncio
    async def test_example_table_json(datasette):
        response = await datasette.client.get(
            "/test/dogs.json?_shape=array"
        )
        assert response.status_code == 200
        assert response.json() == [
            {"id": 1, "name": "Cleo", "age": 5},
            {"id": 2, "name": "Pancakes", "age": 4},
        ]


    @pytest.mark.asyncio
    async def test_example_table_html(datasette):
        response = await datasette.client.get("/test/dogs")
        assert ">Some dogs</h1>" in response.text

Here the ``datasette()`` function defines the fixture, which is than automatically passed to the two test functions based on pytest automatically matching their ``datasette`` function parameters.

The ``@pytest.fixture(scope="session")`` line here ensures the fixture is reused for the full ``pytest`` execution session. This means that the temporary database file will be created once and reused for each test.

If you want to create that test database repeatedly for every individual test function, write the fixture function like this instead. You may want to do this if your plugin modifies the database contents in some way:

.. code-block:: python

    @pytest.fixture
    def datasette(tmp_path_factory):
        # This fixture will be executed repeatedly for every test
        ...

.. _testing_plugins_pytest_httpx:

Testing outbound HTTP calls with pytest-httpx
---------------------------------------------

If your plugin makes outbound HTTP calls - for example datasette-auth-github or datasette-import-table - you may need to mock those HTTP requests in your tests.

The `pytest-httpx <https://pypi.org/project/pytest-httpx/>`__ package is a useful library for mocking calls. It can be tricky to use with Datasette though since it mocks all HTTPX requests, and Datasette's own testing mechanism uses HTTPX internally.

To avoid breaking your tests, you can return ``["localhost"]`` from the ``non_mocked_hosts()`` fixture.

As an example, here's a very simple plugin which executes an HTTP response and returns the resulting content:

.. code-block:: python

    from datasette import hookimpl
    from datasette.utils.asgi import Response
    import httpx


    @hookimpl
    def register_routes():
        return [
            (r"^/-/fetch-url$", fetch_url),
        ]


    async def fetch_url(datasette, request):
        if request.method == "GET":
            return Response.html(
                """
                <form action="/-/fetch-url" method="post">
                <input type="hidden" name="csrftoken" value="{}">
                <input name="url"><input type="submit">
            </form>""".format(
                    request.scope["csrftoken"]()
                )
            )
        vars = await request.post_vars()
        url = vars["url"]
        return Response.text(httpx.get(url).text)

Here's a test for that plugin that mocks the HTTPX outbound request:

.. code-block:: python

    from datasette.app import Datasette
    import pytest


    @pytest.fixture
    def non_mocked_hosts():
        # This ensures httpx-mock will not affect Datasette's own
        # httpx calls made in the tests by datasette.client:
        return ["localhost"]


    async def test_outbound_http_call(httpx_mock):
        httpx_mock.add_response(
            url="https://www.example.com/",
            text="Hello world",
        )
        datasette = Datasette([], memory=True)
        response = await datasette.client.post(
            "/-/fetch-url",
            data={"url": "https://www.example.com/"},
        )
        assert response.text == "Hello world"

        outbound_request = httpx_mock.get_request()
        assert (
            outbound_request.url == "https://www.example.com/"
        )

.. _testing_plugins_register_in_test:

Registering a plugin for the duration of a test
-----------------------------------------------

When writing tests for plugins you may find it useful to register a test plugin just for the duration of a single test. You can do this using ``pm.register()`` and ``pm.unregister()`` like this:

.. code-block:: python

    from datasette import hookimpl
    from datasette.app import Datasette
    from datasette.plugins import pm
    import pytest


    @pytest.mark.asyncio
    async def test_using_test_plugin():
        class TestPlugin:
            __name__ = "TestPlugin"

            # Use hookimpl and method names to register hooks
            @hookimpl
            def register_routes(self):
                return [
                    (r"^/error$", lambda: 1 / 0),
                ]

        pm.register(TestPlugin(), name="undo")
        try:
            # The test implementation goes here
            datasette = Datasette()
            response = await datasette.client.get("/error")
            assert response.status_code == 500
        finally:
            pm.unregister(name="undo")

To reuse the same temporary plugin in multiple tests, you can register it inside a fixture in your ``conftest.py`` file like this:

.. literalinclude:: ../tests/test_docs_plugins.py
   :language: python
   :start-after: # -- start datasette_with_plugin_fixture --
   :end-before: # -- end datasette_with_plugin_fixture --

Note the ``yield`` statement here - this ensures that the ``finally:`` block that unregisters the plugin is executed only after the test function itself has completed.

Then in a test:

.. literalinclude:: ../tests/test_docs_plugins.py
   :language: python
   :start-after: # -- start datasette_with_plugin_test --
   :end-before: # -- end datasette_with_plugin_test --

</document_content>
</document>
<document index="4">
<source>docs/writing_plugins.rst</source>
<document_content>
.. _writing_plugins:

Writing plugins
===============

You can write one-off plugins that apply to just one Datasette instance, or you can write plugins which can be installed using ``pip`` and can be shipped to the Python Package Index (`PyPI <https://pypi.org/>`__) for other people to install.

Want to start by looking at an example? The `Datasette plugins directory <https://datasette.io/plugins>`__ lists more than 90 open source plugins with code you can explore. The :ref:`plugin hooks <plugin_hooks>` page includes links to example plugins for each of the documented hooks.

.. _writing_plugins_tracing:

Tracing plugin hooks
--------------------

The ``DATASETTE_TRACE_PLUGINS`` environment variable turns on detailed tracing showing exactly which hooks are being run. This can be useful for understanding how Datasette is using your plugin.

.. code-block:: bash

    DATASETTE_TRACE_PLUGINS=1 datasette mydb.db

Example output::

    actor_from_request:
    {   'datasette': <datasette.app.Datasette object at 0x100bc7220>,
        'request': <asgi.Request method="GET" url="http://127.0.0.1:4433/">}
    Hook implementations:
    [   <HookImpl plugin_name='codespaces', plugin=<module 'datasette_codespaces' from '.../site-packages/datasette_codespaces/__init__.py'>>,
        <HookImpl plugin_name='datasette.actor_auth_cookie', plugin=<module 'datasette.actor_auth_cookie' from '.../datasette/datasette/actor_auth_cookie.py'>>,
        <HookImpl plugin_name='datasette.default_permissions', plugin=<module 'datasette.default_permissions' from '.../datasette/default_permissions.py'>>]
    Results:
    [{'id': 'root'}]


.. _writing_plugins_one_off:

Writing one-off plugins
-----------------------

The quickest way to start writing a plugin is to create a ``my_plugin.py`` file and drop it into your ``plugins/`` directory. Here is an example plugin, which adds a new custom SQL function called ``hello_world()`` which takes no arguments and returns the string ``Hello world!``.

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def prepare_connection(conn):
        conn.create_function(
            "hello_world", 0, lambda: "Hello world!"
        )

If you save this in ``plugins/my_plugin.py`` you can then start Datasette like this::

    datasette serve mydb.db --plugins-dir=plugins/

Now you can navigate to http://localhost:8001/mydb and run this SQL::

    select hello_world();

To see the output of your plugin.

.. _writing_plugins_cookiecutter:

Starting an installable plugin using cookiecutter
-------------------------------------------------

Plugins that can be installed should be written as Python packages using a ``setup.py`` file.

The quickest way to start writing one an installable plugin is to use the `datasette-plugin <https://github.com/simonw/datasette-plugin>`__ cookiecutter template. This creates a new plugin structure for you complete with an example test and GitHub Actions workflows for testing and publishing your plugin.

`Install cookiecutter <https://cookiecutter.readthedocs.io/en/stable/installation.html>`__ and then run this command to start building a plugin using the template::

    cookiecutter gh:simonw/datasette-plugin

Read `a cookiecutter template for writing Datasette plugins <https://simonwillison.net/2020/Jun/20/cookiecutter-plugins/>`__ for more information about this template.

.. _writing_plugins_packaging:

Packaging a plugin
------------------

Plugins can be packaged using Python setuptools. You can see an example of a packaged plugin at https://github.com/simonw/datasette-plugin-demos

The example consists of two files: a ``setup.py`` file that defines the plugin:

.. code-block:: python

    from setuptools import setup

    VERSION = "0.1"

    setup(
        name="datasette-plugin-demos",
        description="Examples of plugins for Datasette",
        author="Simon Willison",
        url="https://github.com/simonw/datasette-plugin-demos",
        license="Apache License, Version 2.0",
        version=VERSION,
        py_modules=["datasette_plugin_demos"],
        entry_points={
            "datasette": [
                "plugin_demos = datasette_plugin_demos"
            ]
        },
        install_requires=["datasette"],
    )

And a Python module file, ``datasette_plugin_demos.py``, that implements the plugin:

.. code-block:: python

    from datasette import hookimpl
    import random


    @hookimpl
    def prepare_jinja2_environment(env):
        env.filters["uppercase"] = lambda u: u.upper()


    @hookimpl
    def prepare_connection(conn):
        conn.create_function(
            "random_integer", 2, random.randint
        )

Having built a plugin in this way you can turn it into an installable package using the following command::

    python3 setup.py sdist

This will create a ``.tar.gz`` file in the ``dist/`` directory.

You can then install your new plugin into a Datasette virtual environment or Docker container using ``pip``::

    pip install datasette-plugin-demos-0.1.tar.gz

To learn how to upload your plugin to `PyPI <https://pypi.org/>`_ for use by other people, read the PyPA guide to `Packaging and distributing projects <https://packaging.python.org/tutorials/distributing-packages/>`_.

.. _writing_plugins_static_assets:

Static assets
-------------

If your plugin has a ``static/`` directory, Datasette will automatically configure itself to serve those static assets from the following path::

    /-/static-plugins/NAME_OF_PLUGIN_PACKAGE/yourfile.js

Use the ``datasette.urls.static_plugins(plugin_name, path)`` method to generate URLs to that asset that take the ``base_url`` setting into account, see :ref:`internals_datasette_urls`.

To bundle the static assets for a plugin in the package that you publish to PyPI, add the following to the plugin's ``setup.py``:

.. code-block:: python

        package_data = (
            {
                "datasette_plugin_name": [
                    "static/plugin.js",
                ],
            },
        )

Where ``datasette_plugin_name`` is the name of the plugin package (note that it uses underscores, not hyphens) and ``static/plugin.js`` is the path within that package to the static file.

`datasette-cluster-map <https://github.com/simonw/datasette-cluster-map>`__ is a useful example of a plugin that includes packaged static assets in this way.

See :ref:`customization_css` for tips on writing CSS that is compatible with Datasette's default CSS, including details of the ``core`` class for applying Datasette's default form element styles.

.. _writing_plugins_custom_templates:

Custom templates
----------------

If your plugin has a ``templates/`` directory, Datasette will attempt to load templates from that directory before it uses its own default templates.

The priority order for template loading is:

* templates from the ``--template-dir`` argument, if specified
* templates from the ``templates/`` directory in any installed plugins
* default templates that ship with Datasette

See :ref:`customization` for more details on how to write custom templates, including which filenames to use to customize which parts of the Datasette UI.

Templates should be bundled for distribution using the same ``package_data`` mechanism in ``setup.py`` described for static assets above, for example:

.. code-block:: python

        package_data = (
            {
                "datasette_plugin_name": [
                    "templates/my_template.html",
                ],
            },
        )

You can also use wildcards here such as ``templates/*.html``. See `datasette-edit-schema <https://github.com/simonw/datasette-edit-schema>`__ for an example of this pattern.

.. _writing_plugins_configuration:

Writing plugins that accept configuration
-----------------------------------------

When you are writing plugins, you can access plugin configuration like this using the ``datasette plugin_config()`` method. If you know you need plugin configuration for a specific table, you can access it like this::

    plugin_config = datasette.plugin_config(
        "datasette-cluster-map", database="sf-trees", table="Street_Tree_List"
    )

This will return the ``{"latitude_column": "lat", "longitude_column": "lng"}`` in the above example.

If there is no configuration for that plugin, the method will return ``None``.

If it cannot find the requested configuration at the table layer, it will fall back to the database layer and then the root layer. For example, a user may have set the plugin configuration option inside ``datasette.yaml`` like so:

.. [[[cog
    from metadata_doc import metadata_example
    metadata_example(cog, {
        "databases": {
            "sf-trees": {
                "plugins": {
                    "datasette-cluster-map": {
                        "latitude_column": "xlat",
                        "longitude_column": "xlng"
                    }
                }
            }
        }
    })
.. ]]]

.. tab:: metadata.yaml

    .. code-block:: yaml

        databases:
          sf-trees:
            plugins:
              datasette-cluster-map:
                latitude_column: xlat
                longitude_column: xlng


.. tab:: metadata.json

    .. code-block:: json

        {
          "databases": {
            "sf-trees": {
              "plugins": {
                "datasette-cluster-map": {
                  "latitude_column": "xlat",
                  "longitude_column": "xlng"
                }
              }
            }
          }
        }
.. [[[end]]]

In this case, the above code would return that configuration for ANY table within the ``sf-trees`` database.

The plugin configuration could also be set at the top level of ``datasette.yaml``:

.. [[[cog
    metadata_example(cog, {
        "plugins": {
            "datasette-cluster-map": {
                "latitude_column": "xlat",
                "longitude_column": "xlng"
            }
        }
    })
.. ]]]

.. tab:: metadata.yaml

    .. code-block:: yaml

        plugins:
          datasette-cluster-map:
            latitude_column: xlat
            longitude_column: xlng


.. tab:: metadata.json

    .. code-block:: json

        {
          "plugins": {
            "datasette-cluster-map": {
              "latitude_column": "xlat",
              "longitude_column": "xlng"
            }
          }
        }
.. [[[end]]]

Now that ``datasette-cluster-map`` plugin configuration will apply to every table in every database.

.. _writing_plugins_designing_urls:

Designing URLs for your plugin
------------------------------

You can register new URL routes within Datasette using the :ref:`plugin_register_routes` plugin hook.

Datasette's default URLs include these:

- ``/dbname`` - database page
- ``/dbname/tablename`` - table page
- ``/dbname/tablename/pk`` - row page

See :ref:`pages` and :ref:`introspection` for more default URL routes.

To avoid accidentally conflicting with a database file that may be loaded into Datasette, plugins should register URLs using a ``/-/`` prefix. For example, if your plugin adds a new interface for uploading Excel files you might register a URL route like this one:

- ``/-/upload-excel``

Try to avoid registering URLs that clash with other plugins that your users might have installed. There is no central repository of reserved URL paths (yet) but you can review existing plugins by browsing the `plugins directory <https://datasette.io/plugins>`__.

If your plugin includes functionality that relates to a specific database you could also register a URL route like this:

- ``/dbname/-/upload-excel``

Or for a specific table like this:

- ``/dbname/tablename/-/modify-table-schema``

Note that a row could have a primary key of ``-`` and this URL scheme will still work, because Datasette row pages do not ever have a trailing slash followed by additional path components.

.. _writing_plugins_building_urls:

Building URLs within plugins
----------------------------

Plugins that define their own custom user interface elements may need to link to other pages within Datasette.

This can be a bit tricky if the Datasette instance is using the :ref:`setting_base_url` configuration setting to run behind a proxy, since that can cause Datasette's URLs to include an additional prefix.

The ``datasette.urls`` object provides internal methods for correctly generating URLs to different pages within Datasette, taking any ``base_url`` configuration into account.

This object is exposed in templates as the ``urls`` variable, which can be used like this:

.. code-block:: jinja

    Back to the <a href="{{ urls.instance() }}">Homepage</a>

See :ref:`internals_datasette_urls` for full details on this object.

.. _writing_plugins_extra_hooks:

Plugins that define new plugin hooks
------------------------------------

Plugins can define new plugin hooks that other plugins can use to further extend their functionality.

`datasette-graphql <https://github.com/simonw/datasette-graphql>`__ is one example of a plugin that does this. It defines a new hook called ``graphql_extra_fields``, `described here <https://github.com/simonw/datasette-graphql/blob/main/README.md#adding-custom-fields-with-plugins>`__, which other plugins can use to define additional fields that should be included in the GraphQL schema.

To define additional hooks, add a file to the plugin called ``datasette_your_plugin/hookspecs.py`` with content that looks like this:

.. code-block:: python

    from pluggy import HookspecMarker

    hookspec = HookspecMarker("datasette")


    @hookspec
    def name_of_your_hook_goes_here(datasette):
        "Description of your hook."

You should define your own hook name and arguments here, following the documentation for `Pluggy specifications <https://pluggy.readthedocs.io/en/stable/#specs>`__. Make sure to pick a name that is unlikely to clash with hooks provided by any other plugins.

Then, to register your plugin hooks, add the following code to your ``datasette_your_plugin/__init__.py`` file:

.. code-block:: python

    from datasette.plugins import pm
    from . import hookspecs

    pm.add_hookspecs(hookspecs)

This will register your plugin hooks as part of the ``datasette`` plugin hook namespace.

Within your plugin code you can trigger the hook using this pattern:

.. code-block:: python

    from datasette.plugins import pm

    for (
        plugin_return_value
    ) in pm.hook.name_of_your_hook_goes_here(
        datasette=datasette
    ):
        # Do something with plugin_return_value
        pass

Other plugins will then be able to register their own implementations of your hook using this syntax:

.. code-block:: python

    from datasette import hookimpl


    @hookimpl
    def name_of_your_hook_goes_here(datasette):
        return "Response from this plugin hook"

These plugin implementations can accept 0 or more of the named arguments that you defined in your hook specification.

</document_content>
</document>
<document index="5">
<source>docs/internals.rst</source>
<document_content>
.. _internals:

=======================
 Internals for plugins
=======================

Many :ref:`plugin_hooks` are passed objects that provide access to internal Datasette functionality. The interface to these objects should not be considered stable with the exception of methods that are documented here.

.. _internals_request:

Request object
==============

The request object is passed to various plugin hooks. It represents an incoming HTTP request. It has the following properties:

``.scope`` - dictionary
    The ASGI scope that was used to construct this request, described in the `ASGI HTTP connection scope <https://asgi.readthedocs.io/en/latest/specs/www.html#connection-scope>`__ specification.

``.method`` - string
    The HTTP method for this request, usually ``GET`` or ``POST``.

``.url`` - string
    The full URL for this request, e.g. ``https://latest.datasette.io/fixtures``.

``.scheme`` - string
    The request scheme - usually ``https`` or ``http``.

``.headers`` - dictionary (str -> str)
    A dictionary of incoming HTTP request headers. Header names have been converted to lowercase.

``.cookies`` - dictionary (str -> str)
    A dictionary of incoming cookies

``.host`` - string
    The host header from the incoming request, e.g. ``latest.datasette.io`` or ``localhost``.

``.path`` - string
    The path of the request excluding the query string, e.g. ``/fixtures``.

``.full_path`` - string
    The path of the request including the query string if one is present, e.g. ``/fixtures?sql=select+sqlite_version()``.

``.query_string`` - string
    The query string component of the request, without the ``?`` - e.g. ``name__contains=sam&age__gt=10``.

``.args`` - MultiParams
    An object representing the parsed query string parameters, see below.

``.url_vars`` - dictionary (str -> str)
    Variables extracted from the URL path, if that path was defined using a regular expression. See :ref:`plugin_register_routes`.

``.actor`` - dictionary (str -> Any) or None
    The currently authenticated actor (see :ref:`actors <authentication_actor>`), or ``None`` if the request is unauthenticated.

The object also has two awaitable methods:

``await request.post_vars()`` - dictionary
    Returns a dictionary of form variables that were submitted in the request body via ``POST``. Don't forget to read about :ref:`internals_csrf`!

``await request.post_body()`` - bytes
    Returns the un-parsed body of a request submitted by ``POST`` - useful for things like incoming JSON data.

And a class method that can be used to create fake request objects for use in tests:

``fake(path_with_query_string, method="GET", scheme="http", url_vars=None)``
    Returns a ``Request`` instance for the specified path and method. For example:

    .. code-block:: python

        from datasette import Request
        from pprint import pprint

        request = Request.fake(
            "/fixtures/facetable/",
            url_vars={"database": "fixtures", "table": "facetable"},
        )
        pprint(request.scope)

    This outputs::

        {'http_version': '1.1',
         'method': 'GET',
         'path': '/fixtures/facetable/',
         'query_string': b'',
         'raw_path': b'/fixtures/facetable/',
         'scheme': 'http',
         'type': 'http',
         'url_route': {'kwargs': {'database': 'fixtures', 'table': 'facetable'}}}

.. _internals_multiparams:

The MultiParams class
=====================

``request.args`` is a ``MultiParams`` object - a dictionary-like object which provides access to query string parameters that may have multiple values.

Consider the query string ``?foo=1&foo=2&bar=3`` - with two values for ``foo`` and one value for ``bar``.

``request.args[key]`` - string
    Returns the first value for that key, or raises a ``KeyError`` if the key is missing. For the above example ``request.args["foo"]`` would return ``"1"``.

``request.args.get(key)`` - string or None
    Returns the first value for that key, or ``None`` if the key is missing. Pass a second argument to specify a different default, e.g. ``q = request.args.get("q", "")``.

``request.args.getlist(key)`` - list of strings
    Returns the list of strings for that key. ``request.args.getlist("foo")`` would return ``["1", "2"]`` in the above example. ``request.args.getlist("bar")`` would return ``["3"]``. If the key is missing an empty list will be returned.

``request.args.keys()`` - list of strings
    Returns the list of available keys - for the example this would be ``["foo", "bar"]``.

``key in request.args`` - True or False
    You can use ``if key in request.args`` to check if a key is present.

``for key in request.args`` - iterator
    This lets you loop through every available key.

``len(request.args)`` - integer
    Returns the number of keys.

.. _internals_response:

Response class
==============

The ``Response`` class can be returned from view functions that have been registered using the :ref:`plugin_register_routes` hook.

The ``Response()`` constructor takes the following arguments:

``body`` - string
    The body of the response.

``status`` - integer (optional)
    The HTTP status - defaults to 200.

``headers`` - dictionary (optional)
    A dictionary of extra HTTP headers, e.g. ``{"x-hello": "world"}``.

``content_type`` - string (optional)
    The content-type for the response. Defaults to ``text/plain``.

For example:

.. code-block:: python

    from datasette.utils.asgi import Response

    response = Response(
        "<xml>This is XML</xml>",
        content_type="application/xml; charset=utf-8",
    )

The quickest way to create responses is using the ``Response.text(...)``, ``Response.html(...)``, ``Response.json(...)`` or ``Response.redirect(...)`` helper methods:

.. code-block:: python

    from datasette.utils.asgi import Response

    html_response = Response.html("This is HTML")
    json_response = Response.json({"this_is": "json"})
    text_response = Response.text(
        "This will become utf-8 encoded text"
    )
    # Redirects are served as 302, unless you pass status=301:
    redirect_response = Response.redirect(
        "https://latest.datasette.io/"
    )

Each of these responses will use the correct corresponding content-type - ``text/html; charset=utf-8``, ``application/json; charset=utf-8`` or ``text/plain; charset=utf-8`` respectively.

Each of the helper methods take optional ``status=`` and ``headers=`` arguments, documented above.

.. _internals_response_asgi_send:

Returning a response with .asgi_send(send)
------------------------------------------

In most cases you will return ``Response`` objects from your own view functions. You can also use a ``Response`` instance to respond at a lower level via ASGI, for example if you are writing code that uses the :ref:`plugin_asgi_wrapper` hook.

Create a ``Response`` object and then use ``await response.asgi_send(send)``, passing the ASGI ``send`` function. For example:

.. code-block:: python

    async def require_authorization(scope, receive, send):
        response = Response.text(
            "401 Authorization Required",
            headers={
                "www-authenticate": 'Basic realm="Datasette", charset="UTF-8"'
            },
            status=401,
        )
        await response.asgi_send(send)

.. _internals_response_set_cookie:

Setting cookies with response.set_cookie()
------------------------------------------

To set cookies on the response, use the ``response.set_cookie(...)`` method. The method signature looks like this:

.. code-block:: python

    def set_cookie(
        self,
        key,
        value="",
        max_age=None,
        expires=None,
        path="/",
        domain=None,
        secure=False,
        httponly=False,
        samesite="lax",
    ): ...

You can use this with :ref:`datasette.sign() <datasette_sign>` to set signed cookies. Here's how you would set the :ref:`ds_actor cookie <authentication_ds_actor>` for use with Datasette :ref:`authentication <authentication>`:

.. code-block:: python

    response = Response.redirect("/")
    response.set_cookie(
        "ds_actor",
        datasette.sign({"a": {"id": "cleopaws"}}, "actor"),
    )
    return response

.. _internals_datasette:

Datasette class
===============

This object is an instance of the ``Datasette`` class, passed to many plugin hooks as an argument called ``datasette``.

You can create your own instance of this - for example to help write tests for a plugin - like so:

.. code-block:: python

    from datasette.app import Datasette

    # With no arguments a single in-memory database will be attached
    datasette = Datasette()

    # The files= argument can load files from disk
    datasette = Datasette(files=["/path/to/my-database.db"])

    # Pass metadata as a JSON dictionary like this
    datasette = Datasette(
        files=["/path/to/my-database.db"],
        metadata={
            "databases": {
                "my-database": {
                    "description": "This is my database"
                }
            }
        },
    )

Constructor parameters include:

- ``files=[...]`` - a list of database files to open
- ``immutables=[...]`` - a list of database files to open in immutable mode
- ``metadata={...}`` - a dictionary of :ref:`metadata`
- ``config_dir=...`` - the :ref:`configuration directory <config_dir>` to use, stored in ``datasette.config_dir``

.. _datasette_databases:

.databases
----------

Property exposing a ``collections.OrderedDict`` of databases currently connected to Datasette.

The dictionary keys are the name of the database that is used in the URL - e.g. ``/fixtures`` would have a key of ``"fixtures"``. The values are :ref:`internals_database` instances.

All databases are listed, irrespective of user permissions.

.. _datasette_permissions:

.permissions
------------

Property exposing a dictionary of permissions that have been registered using the :ref:`plugin_register_permissions` plugin hook.

The dictionary keys are the permission names - e.g. ``view-instance`` - and the values are ``Permission()`` objects describing the permission. Here is a :ref:`description of that object <plugin_register_permissions>`.

.. _datasette_plugin_config:

.plugin_config(plugin_name, database=None, table=None)
------------------------------------------------------

``plugin_name`` - string
    The name of the plugin to look up configuration for. Usually this is something similar to ``datasette-cluster-map``.

``database`` - None or string
    The database the user is interacting with.

``table`` - None or string
    The table the user is interacting with.

This method lets you read plugin configuration values that were set in  ``datasette.yaml``. See :ref:`writing_plugins_configuration` for full details of how this method should be used.

The return value will be the value from the configuration file - usually a dictionary.

If the plugin is not configured the return value will be ``None``.

.. _datasette_render_template:

await .render_template(template, context=None, request=None)
------------------------------------------------------------

``template`` - string, list of strings or jinja2.Template
    The template file to be rendered, e.g. ``my_plugin.html``. Datasette will search for this file first in the ``--template-dir=`` location, if it was specified - then in the plugin's bundled templates and finally in Datasette's set of default templates.

    If this is a list of template file names then the first one that exists will be loaded and rendered.

    If this is a Jinja `Template object <https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template>`__ it will be used directly.

``context`` - None or a Python dictionary
    The context variables to pass to the template.

``request`` - request object or None
    If you pass a Datasette request object here it will be made available to the template.

Renders a `Jinja template <https://jinja.palletsprojects.com/en/2.11.x/>`__ using Datasette's preconfigured instance of Jinja and returns the resulting string. The template will have access to Datasette's default template functions and any functions that have been made available by other plugins.

.. _datasette_actors_from_ids:

await .actors_from_ids(actor_ids)
---------------------------------

``actor_ids`` - list of strings or integers
    A list of actor IDs to look up.

Returns a dictionary, where the keys are the IDs passed to it and the values are the corresponding actor dictionaries.

This method is mainly designed to be used with plugins. See the :ref:`plugin_hook_actors_from_ids` documentation for details.

If no plugins that implement that hook are installed, the default return value looks like this:

.. code-block:: json

    {
        "1": {"id": "1"},
        "2": {"id": "2"}
    }

.. _datasette_permission_allowed:

await .permission_allowed(actor, action, resource=None, default=...)
--------------------------------------------------------------------

``actor`` - dictionary
    The authenticated actor. This is usually ``request.actor``.

``action`` - string
    The name of the action that is being permission checked.

``resource`` - string or tuple, optional
    The resource, e.g. the name of the database, or a tuple of two strings containing the name of the database and the name of the table. Only some permissions apply to a resource.

``default`` - optional: True, False or None
    What value should be returned by default if nothing provides an opinion on this permission check.
    Set to ``True`` for default allow or ``False`` for default deny.
    If not specified the ``default`` from the ``Permission()`` tuple that was registered using :ref:`plugin_register_permissions` will be used.

Check if the given actor has :ref:`permission <authentication_permissions>` to perform the given action on the given resource.

Some permission checks are carried out against :ref:`rules defined in datasette.yaml <authentication_permissions_config>`, while other custom permissions may be decided by plugins that implement the :ref:`plugin_hook_permission_allowed` plugin hook.

If neither ``metadata.json`` nor any of the plugins provide an answer to the permission query the ``default`` argument will be returned.

See :ref:`permissions` for a full list of permission actions included in Datasette core.

.. _datasette_ensure_permissions:

await .ensure_permissions(actor, permissions)
---------------------------------------------

``actor`` - dictionary
    The authenticated actor. This is usually ``request.actor``.

``permissions`` - list
    A list of permissions to check. Each permission in that list can be a string ``action`` name or a 2-tuple of ``(action, resource)``.

This method allows multiple permissions to be checked at once. It raises a ``datasette.Forbidden`` exception if any of the checks are denied before one of them is explicitly granted.

This is useful when you need to check multiple permissions at once. For example, an actor should be able to view a table if either one of the following checks returns ``True`` or not a single one of them returns ``False``:

.. code-block:: python

    await datasette.ensure_permissions(
        request.actor,
        [
            ("view-table", (database, table)),
            ("view-database", database),
            "view-instance",
        ],
    )

.. _datasette_check_visibility:

await .check_visibility(actor, action=None, resource=None, permissions=None)
----------------------------------------------------------------------------

``actor`` - dictionary
    The authenticated actor. This is usually ``request.actor``.

``action`` - string, optional
    The name of the action that is being permission checked.

``resource`` - string or tuple, optional
    The resource, e.g. the name of the database, or a tuple of two strings containing the name of the database and the name of the table. Only some permissions apply to a resource.

``permissions`` - list of ``action`` strings or ``(action, resource)`` tuples, optional
    Provide this instead of ``action`` and ``resource`` to check multiple permissions at once.

This convenience method can be used to answer the question "should this item be considered private, in that it is visible to me but it is not visible to anonymous users?"

It returns a tuple of two booleans, ``(visible, private)``. ``visible`` indicates if the actor can see this resource. ``private`` will be ``True`` if an anonymous user would not be able to view the resource.

This example checks if the user can access a specific table, and sets ``private`` so that a padlock icon can later be displayed:

.. code-block:: python

    visible, private = await datasette.check_visibility(
        request.actor,
        action="view-table",
        resource=(database, table),
    )

The following example runs three checks in a row, similar to :ref:`datasette_ensure_permissions`. If any of the checks are denied before one of them is explicitly granted then ``visible`` will be ``False``. ``private`` will be ``True`` if an anonymous user would not be able to view the resource.

.. code-block:: python

    visible, private = await datasette.check_visibility(
        request.actor,
        permissions=[
            ("view-table", (database, table)),
            ("view-database", database),
            "view-instance",
        ],
    )

.. _datasette_create_token:

.create_token(actor_id, expires_after=None, restrict_all=None, restrict_database=None, restrict_resource=None)
--------------------------------------------------------------------------------------------------------------

``actor_id`` - string
    The ID of the actor to create a token for.

``expires_after`` - int, optional
    The number of seconds after which the token should expire.

``restrict_all`` - iterable, optional
    A list of actions that this token should be restricted to across all databases and resources.

``restrict_database`` - dict, optional
    For restricting actions within specific databases, e.g. ``{"mydb": ["view-table", "view-query"]}``.

``restrict_resource`` - dict, optional
    For restricting actions to specific resources (tables, SQL views and :ref:`canned_queries`) within a database. For example: ``{"mydb": {"mytable": ["insert-row", "update-row"]}}``.

This method returns a signed :ref:`API token <CreateTokenView>` of the format ``dstok_...`` which can be used to authenticate requests to the Datasette API.

All tokens must have an ``actor_id`` string indicating the ID of the actor which the token will act on behalf of.

Tokens default to lasting forever, but can be set to expire after a given number of seconds using the ``expires_after`` argument. The following code creates a token for ``user1`` that will expire after an hour:

.. code-block:: python

    token = datasette.create_token(
        actor_id="user1",
        expires_after=3600,
    )

The three ``restrict_*`` arguments can be used to create a token that has additional restrictions beyond what the associated actor is allowed to do.

The following example creates a token that can access ``view-instance`` and ``view-table`` across everything, can additionally use ``view-query`` for anything in the ``docs`` database and is allowed to execute ``insert-row`` and ``update-row`` in the ``attachments`` table in that database:

.. code-block:: python

    token = datasette.create_token(
        actor_id="user1",
        restrict_all=("view-instance", "view-table"),
        restrict_database={"docs": ("view-query",)},
        restrict_resource={
            "docs": {
                "attachments": ("insert-row", "update-row")
            }
        },
    )

.. _datasette_get_permission:

.get_permission(name_or_abbr)
-----------------------------

``name_or_abbr`` - string
    The name or abbreviation of the permission to look up, e.g. ``view-table`` or ``vt``.

Returns a :ref:`Permission object <plugin_register_permissions>` representing the permission, or raises a ``KeyError`` if one is not found.

.. _datasette_get_database:

.get_database(name)
-------------------

``name`` - string, optional
    The name of the database - optional.

Returns the specified database object. Raises a ``KeyError`` if the database does not exist. Call this method without an argument to return the first connected database.

.. _get_internal_database:

.get_internal_database()
------------------------

Returns a database object for reading and writing to the private :ref:`internal database <internals_internal>`.

.. _datasette_get_set_metadata:

Getting and setting metadata
----------------------------

Metadata about the instance, databases, tables and columns is stored in tables in :ref:`internals_internal`. The following methods are the supported API for plugins to read and update that stored metadata.

.. _datasette_get_instance_metadata:

await .get_instance_metadata(self)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Returns metadata keys and values for the entire Datasette instance as a dictionary.
Internally queries the ``metadata_instance`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_get_database_metadata:

await .get_database_metadata(self, database_name)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``database_name`` - string
    The name of the database to query.

Returns metadata keys and values for the specified database as a dictionary.
Internally queries the ``metadata_databases`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_get_resource_metadata:

await .get_resource_metadata(self, database_name, resource_name)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``database_name`` - string
    The name of the database to query.
``resource_name`` - string
    The name of the resource (table, view, or canned query) inside ``database_name`` to query.

Returns metadata keys and values for the specified "resource" as a dictionary.
A "resource" in this context can be a table, view, or canned query.
Internally queries the ``metadata_resources`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_get_column_metadata:

await .get_column_metadata(self, database_name, resource_name, column_name)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``database_name`` - string
    The name of the database to query.
``resource_name`` - string
    The name of the resource (table, view, or canned query) inside ``database_name`` to query.
``column_name`` - string
    The name of the column inside ``resource_name`` to query.


Returns metadata keys and values for the specified column, resource, and table as a dictionary.
Internally queries the ``metadata_columns`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_set_instance_metadata:

await .set_instance_metadata(self, key, value)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``key`` - string
    The metadata entry key to insert (ex ``title``, ``description``, etc.)
``value`` - string
    The value of the metadata entry to insert.

Adds a new metadata entry for the entire Datasette instance.
Any previous instance-level metadata entry with the same ``key`` will be overwritten.
Internally upserts the value into the  the ``metadata_instance`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_set_database_metadata:

await .set_database_metadata(self, database_name, key, value)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``database_name`` - string
    The database the metadata entry belongs to.
``key`` - string
    The metadata entry key to insert (ex ``title``, ``description``, etc.)
``value`` - string
    The value of the metadata entry to insert.

Adds a new metadata entry for the specified database.
Any previous database-level metadata entry with the same ``key`` will be overwritten.
Internally upserts the value into the  the ``metadata_databases`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_set_resource_metadata:

await .set_resource_metadata(self, database_name, resource_name, key, value)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``database_name`` - string
    The database the metadata entry belongs to.
``resource_name`` - string
    The resource (table, view, or canned query) the metadata entry belongs to.
``key`` - string
    The metadata entry key to insert (ex ``title``, ``description``, etc.)
``value`` - string
    The value of the metadata entry to insert.

Adds a new metadata entry for the specified "resource".
Any previous resource-level metadata entry with the same ``key`` will be overwritten.
Internally upserts the value into the  the ``metadata_resources`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_set_column_metadata:

await .set_column_metadata(self, database_name, resource_name, column_name, key, value)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``database_name`` - string
    The database the metadata entry belongs to.
``resource_name`` - string
    The resource (table, view, or canned query) the metadata entry belongs to.
``column-name`` - string
    The column the metadata entry belongs to.
``key`` - string
    The metadata entry key to insert (ex ``title``, ``description``, etc.)
``value`` - string
    The value of the metadata entry to insert.

Adds a new metadata entry for the specified column.
Any previous column-level metadata entry with the same ``key`` will be overwritten.
Internally upserts the value into the  the ``metadata_columns`` table inside the :ref:`internal database <internals_internal>`.

.. _datasette_add_database:

.add_database(db, name=None, route=None)
----------------------------------------

``db`` - datasette.database.Database instance
    The database to be attached.

``name`` - string, optional
    The name to be used for this database . If not specified Datasette will pick one based on the filename or memory name.

``route`` - string, optional
    This will be used in the URL path. If not specified, it will default to the same thing as the ``name``.

The ``datasette.add_database(db)`` method lets you add a new database to the current Datasette instance.

The ``db`` parameter should be an instance of the ``datasette.database.Database`` class. For example:

.. code-block:: python

    from datasette.database import Database

    datasette.add_database(
        Database(
            datasette,
            path="path/to/my-new-database.db",
        )
    )

This will add a mutable database and serve it at ``/my-new-database``.

Use ``is_mutable=False`` to add an immutable database.

``.add_database()`` returns the Database instance, with its name set as the ``database.name`` attribute. Any time you are working with a newly added database you should use the return value of ``.add_database()``, for example:

.. code-block:: python

    db = datasette.add_database(
        Database(datasette, memory_name="statistics")
    )
    await db.execute_write(
        "CREATE TABLE foo(id integer primary key)"
    )

.. _datasette_add_memory_database:

.add_memory_database(name)
--------------------------

Adds a shared in-memory database with the specified name:

.. code-block:: python

    datasette.add_memory_database("statistics")

This is a shortcut for the following:

.. code-block:: python

    from datasette.database import Database

    datasette.add_database(
        Database(datasette, memory_name="statistics")
    )

Using either of these pattern will result in the in-memory database being served at ``/statistics``.

.. _datasette_remove_database:

.remove_database(name)
----------------------

``name`` - string
    The name of the database to be removed.

This removes a database that has been previously added. ``name=`` is the unique name of that database.

.. _datasette_track_event:

await .track_event(event)
-------------------------

``event`` - ``Event``
    An instance of a subclass of ``datasette.events.Event``.

Plugins can call this to track events, using classes they have previously registered. See :ref:`plugin_event_tracking` for details.

The event will then be passed to all plugins that have registered to receive events using the :ref:`plugin_hook_track_event` hook.

Example usage, assuming the plugin has previously registered the ``BanUserEvent`` class:

.. code-block:: python

    await datasette.track_event(
        BanUserEvent(user={"id": 1, "username": "cleverbot"})
    )

.. _datasette_sign:

.sign(value, namespace="default")
---------------------------------

``value`` - any serializable type
    The value to be signed.

``namespace`` - string, optional
    An alternative namespace, see the `itsdangerous salt documentation <https://itsdangerous.palletsprojects.com/en/1.1.x/serializer/#the-salt>`__.

Utility method for signing values, such that you can safely pass data to and from an untrusted environment. This is a wrapper around the `itsdangerous <https://itsdangerous.palletsprojects.com/>`__ library.

This method returns a signed string, which can be decoded and verified using :ref:`datasette_unsign`.

.. _datasette_unsign:

.unsign(value, namespace="default")
-----------------------------------

``signed`` - any serializable type
    The signed string that was created using :ref:`datasette_sign`.

``namespace`` - string, optional
    The alternative namespace, if one was used.

Returns the original, decoded object that was passed to :ref:`datasette_sign`. If the signature is not valid this raises a ``itsdangerous.BadSignature`` exception.

.. _datasette_add_message:

.add_message(request, message, type=datasette.INFO)
---------------------------------------------------

``request`` - Request
    The current Request object

``message`` - string
    The message string

``type`` - constant, optional
    The message type - ``datasette.INFO``, ``datasette.WARNING`` or ``datasette.ERROR``

Datasette's flash messaging mechanism allows you to add a message that will be displayed to the user on the next page that they visit. Messages are persisted in a ``ds_messages`` cookie. This method adds a message to that cookie.

You can try out these messages (including the different visual styling of the three message types) using the ``/-/messages`` debugging tool.

.. _datasette_absolute_url:

.absolute_url(request, path)
----------------------------

``request`` - Request
    The current Request object

``path`` - string
    A path, for example ``/dbname/table.json``

Returns the absolute URL for the given path, including the protocol and host. For example:

.. code-block:: python

    absolute_url = datasette.absolute_url(
        request, "/dbname/table.json"
    )
    # Would return "http://localhost:8001/dbname/table.json"

The current request object is used to determine the hostname and protocol that should be used for the returned URL. The :ref:`setting_force_https_urls` configuration setting is taken into account.

.. _datasette_setting:

.setting(key)
-------------

``key`` - string
    The name of the setting, e.g. ``base_url``.

Returns the configured value for the specified :ref:`setting <settings>`. This can be a string, boolean or integer depending on the requested setting.

For example:

.. code-block:: python

    downloads_are_allowed = datasette.setting("allow_download")

.. _datasette_resolve_database:

.resolve_database(request)
--------------------------

``request`` - :ref:`internals_request`
    A request object

If you are implementing your own custom views, you may need to resolve the database that the user is requesting based on a URL path. If the regular expression for your route declares a ``database`` named group, you can use this method to resolve the database object.

This returns a :ref:`Database <internals_database>` instance.

If the database cannot be found, it raises a ``datasette.utils.asgi.DatabaseNotFound`` exception - which is a subclass of ``datasette.utils.asgi.NotFound`` with a ``.database_name`` attribute set to the name of the database that was requested.

.. _datasette_resolve_table:

.resolve_table(request)
-----------------------

``request`` - :ref:`internals_request`
    A request object

This assumes that the regular expression for your route declares both a ``database`` and a ``table`` named group.

It returns a ``ResolvedTable`` named tuple instance with the following fields:

``db`` - :ref:`Database <internals_database>`
    The database object

``table`` - string
    The name of the table (or view)

``is_view`` - boolean
    ``True`` if this is a view, ``False`` if it is a table

If the database or table cannot be found it raises a ``datasette.utils.asgi.DatabaseNotFound`` exception.

If the table does not exist it raises a ``datasette.utils.asgi.TableNotFound`` exception - a subclass of ``datasette.utils.asgi.NotFound`` with ``.database_name`` and ``.table`` attributes.

.. _datasette_resolve_row:

.resolve_row(request)
---------------------

``request`` - :ref:`internals_request`
    A request object

This method assumes your route declares named groups for ``database``, ``table`` and ``pks``.

It returns a ``ResolvedRow`` named tuple instance with the following fields:

``db`` - :ref:`Database <internals_database>`
    The database object

``table`` - string
    The name of the table

``sql`` - string
    SQL snippet that can be used in a ``WHERE`` clause to select the row

``params`` - dict
    Parameters that should be passed to the SQL query

``pks`` - list
    List of primary key column names

``pk_values`` - list
    List of primary key values decoded from the URL

``row`` - ``sqlite3.Row``
    The row itself

If the database or table cannot be found it raises a ``datasette.utils.asgi.DatabaseNotFound`` exception.

If the table does not exist it raises a ``datasette.utils.asgi.TableNotFound`` exception.

If the row cannot be found it raises a ``datasette.utils.asgi.RowNotFound`` exception. This has ``.database_name``, ``.table`` and ``.pk_values`` attributes, extracted from the request path.

.. _internals_datasette_client:

datasette.client
----------------

Plugins can make internal simulated HTTP requests to the Datasette instance within which they are running. This ensures that all of Datasette's external JSON APIs are also available to plugins, while avoiding the overhead of making an external HTTP call to access those APIs.

The ``datasette.client`` object is a wrapper around the `HTTPX Python library <https://www.python-httpx.org/>`__, providing an async-friendly API that is similar to the widely used `Requests library <https://requests.readthedocs.io/>`__.

It offers the following methods:

``await datasette.client.get(path, **kwargs)`` - returns HTTPX Response
    Execute an internal GET request against that path.

``await datasette.client.post(path, **kwargs)`` - returns HTTPX Response
    Execute an internal POST request. Use ``data={"name": "value"}`` to pass form parameters.

``await datasette.client.options(path, **kwargs)`` - returns HTTPX Response
    Execute an internal OPTIONS request.

``await datasette.client.head(path, **kwargs)`` - returns HTTPX Response
    Execute an internal HEAD request.

``await datasette.client.put(path, **kwargs)`` - returns HTTPX Response
    Execute an internal PUT request.

``await datasette.client.patch(path, **kwargs)`` - returns HTTPX Response
    Execute an internal PATCH request.

``await datasette.client.delete(path, **kwargs)`` - returns HTTPX Response
    Execute an internal DELETE request.

``await datasette.client.request(method, path, **kwargs)`` - returns HTTPX Response
    Execute an internal request with the given HTTP method against that path.

These methods can be used with :ref:`internals_datasette_urls` - for example:

.. code-block:: python

    table_json = (
        await datasette.client.get(
            datasette.urls.table(
                "fixtures", "facetable", format="json"
            )
        )
    ).json()

``datasette.client`` methods automatically take the current :ref:`setting_base_url` setting into account, whether or not you use the ``datasette.urls`` family of methods to construct the path.

For documentation on available ``**kwargs`` options and the shape of the HTTPX Response object refer to the `HTTPX Async documentation <https://www.python-httpx.org/async/>`__.

.. _internals_datasette_urls:

datasette.urls
--------------

The ``datasette.urls`` object contains methods for building URLs to pages within Datasette. Plugins should use this to link to pages, since these methods take into account any :ref:`setting_base_url` configuration setting that might be in effect.

``datasette.urls.instance(format=None)``
    Returns the URL to the Datasette instance root page. This is usually ``"/"``.

``datasette.urls.path(path, format=None)``
    Takes a path and returns the full path, taking ``base_url`` into account.

    For example, ``datasette.urls.path("-/logout")`` will return the path to the logout page, which will be ``"/-/logout"`` by default or ``/prefix-path/-/logout`` if ``base_url`` is set to ``/prefix-path/``

``datasette.urls.logout()``
    Returns the URL to the logout page, usually ``"/-/logout"``

``datasette.urls.static(path)``
    Returns the URL of one of Datasette's default static assets, for example ``"/-/static/app.css"``

``datasette.urls.static_plugins(plugin_name, path)``
    Returns the URL of one of the static assets belonging to a plugin.

    ``datasette.urls.static_plugins("datasette_cluster_map", "datasette-cluster-map.js")`` would return ``"/-/static-plugins/datasette_cluster_map/datasette-cluster-map.js"``

``datasette.urls.static(path)``
    Returns the URL of one of Datasette's default static assets, for example ``"/-/static/app.css"``

``datasette.urls.database(database_name, format=None)``
    Returns the URL to a database page, for example ``"/fixtures"``

``datasette.urls.table(database_name, table_name, format=None)``
    Returns the URL to a table page, for example ``"/fixtures/facetable"``

``datasette.urls.query(database_name, query_name, format=None)``
    Returns the URL to a query page, for example ``"/fixtures/pragma_cache_size"``

These functions can be accessed via the ``{{ urls }}`` object in Datasette templates, for example:

.. code-block:: jinja

    <a href="{{ urls.instance() }}">Homepage</a>
    <a href="{{ urls.database("fixtures") }}">Fixtures database</a>
    <a href="{{ urls.table("fixtures", "facetable") }}">facetable table</a>
    <a href="{{ urls.query("fixtures", "pragma_cache_size") }}">pragma_cache_size query</a>

Use the ``format="json"`` (or ``"csv"`` or other formats supported by plugins) arguments to get back URLs to the JSON representation. This is the path with ``.json`` added on the end.

These methods each return a ``datasette.utils.PrefixedUrlString`` object, which is a subclass of the Python ``str`` type. This allows the logic that considers the ``base_url`` setting to detect if that prefix has already been applied to the path.

.. _internals_database:

Database class
==============

Instances of the ``Database`` class can be used to execute queries against attached SQLite databases, and to run introspection against their schemas.

.. _database_constructor:

Database(ds, path=None, is_mutable=True, is_memory=False, memory_name=None)
---------------------------------------------------------------------------

The ``Database()`` constructor can be used by plugins, in conjunction with :ref:`datasette_add_database`, to create and register new databases.

The arguments are as follows:

``ds`` - :ref:`internals_datasette` (required)
    The Datasette instance you are attaching this database to.

``path`` - string
    Path to a SQLite database file on disk.

``is_mutable`` - boolean
    Set this to ``False`` to cause Datasette to open the file in immutable mode.

``is_memory`` - boolean
    Use this to create non-shared memory connections.

``memory_name`` - string or ``None``
    Use this to create a named in-memory database. Unlike regular memory databases these can be accessed by multiple threads and will persist an changes made to them for the lifetime of the Datasette server process.

The first argument is the ``datasette`` instance you are attaching to, the second is a ``path=``, then ``is_mutable`` and ``is_memory`` are both optional arguments.

.. _database_hash:

db.hash
-------

If the database was opened in immutable mode, this property returns the 64 character SHA-256 hash of the database contents as a string. Otherwise it returns ``None``.

.. _database_execute:

await db.execute(sql, ...)
--------------------------

Executes a SQL query against the database and returns the resulting rows (see :ref:`database_results`).

``sql`` - string (required)
    The SQL query to execute. This can include ``?`` or ``:named`` parameters.

``params`` - list or dict
    A list or dictionary of values to use for the parameters. List for ``?``, dictionary for ``:named``.

``truncate`` - boolean
    Should the rows returned by the query be truncated at the maximum page size? Defaults to ``True``, set this to ``False`` to disable truncation.

``custom_time_limit`` - integer ms
    A custom time limit for this query. This can be set to a lower value than the Datasette configured default. If a query takes longer than this it will be terminated early and raise a ``dataette.database.QueryInterrupted`` exception.

``page_size`` - integer
    Set a custom page size for truncation, over-riding the configured Datasette default.

``log_sql_errors`` - boolean
    Should any SQL errors be logged to the console in addition to being raised as an error? Defaults to ``True``.

.. _database_results:

Results
-------

The ``db.execute()`` method returns a single ``Results`` object. This can be used to access the rows returned by the query.

Iterating over a ``Results`` object will yield SQLite `Row objects <https://docs.python.org/3/library/sqlite3.html#row-objects>`__. Each of these can be treated as a tuple or can be accessed using ``row["column"]`` syntax:

.. code-block:: python

    info = []
    results = await db.execute("select name from sqlite_master")
    for row in results:
        info.append(row["name"])

The ``Results`` object also has the following properties and methods:

``.truncated`` - boolean
    Indicates if this query was truncated - if it returned more results than the specified ``page_size``. If this is true then the results object will only provide access to the first ``page_size`` rows in the query result. You can disable truncation by passing ``truncate=False`` to the ``db.query()`` method.

``.columns`` - list of strings
    A list of column names returned by the query.

``.rows`` - list of ``sqlite3.Row``
    This property provides direct access to the list of rows returned by the database. You can access specific rows by index using ``results.rows[0]``.

``.dicts()`` - list of ``dict``
    This method returns a list of Python dictionaries, one for each row.

``.first()`` - row or None
    Returns the first row in the results, or ``None`` if no rows were returned.

``.single_value()``
    Returns the value of the first column of the first row of results - but only if the query returned a single row with a single column. Raises a ``datasette.database.MultipleValues`` exception otherwise.

``.__len__()``
    Calling ``len(results)`` returns the (truncated) number of returned results.

.. _database_execute_fn:

await db.execute_fn(fn)
-----------------------

Executes a given callback function against a read-only database connection running in a thread. The function will be passed a SQLite connection, and the return value from the function will be returned by the ``await``.

Example usage:

.. code-block:: python

    def get_version(conn):
        return conn.execute(
            "select sqlite_version()"
        ).fetchall()[0][0]


    version = await db.execute_fn(get_version)

.. _database_execute_write:

await db.execute_write(sql, params=None, block=True)
-----------------------------------------------------

SQLite only allows one database connection to write at a time. Datasette handles this for you by maintaining a queue of writes to be executed against a given database. Plugins can submit write operations to this queue and they will be executed in the order in which they are received.

This method can be used to queue up a non-SELECT SQL query to be executed against a single write connection to the database.

You can pass additional SQL parameters as a tuple or dictionary.

The method will block until the operation is completed, and the return value will be the return from calling ``conn.execute(...)`` using the underlying ``sqlite3`` Python library.

If you pass ``block=False`` this behavior changes to "fire and forget" - queries will be added to the write queue and executed in a separate thread while your code can continue to do other things. The method will return a UUID representing the queued task.

Each call to ``execute_write()`` will be executed inside a transaction.

.. _database_execute_write_script:

await db.execute_write_script(sql, block=True)
-----------------------------------------------

Like ``execute_write()`` but can be used to send multiple SQL statements in a single string separated by semicolons, using the ``sqlite3`` `conn.executescript() <https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.executescript>`__ method.

Each call to ``execute_write_script()`` will be executed inside a transaction.

.. _database_execute_write_many:

await db.execute_write_many(sql, params_seq, block=True)
---------------------------------------------------------

Like ``execute_write()`` but uses the ``sqlite3`` `conn.executemany() <https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.executemany>`__ method. This will efficiently execute the same SQL statement against each of the parameters in the ``params_seq`` iterator, for example:

.. code-block:: python

    await db.execute_write_many(
        "insert into characters (id, name) values (?, ?)",
        [(1, "Melanie"), (2, "Selma"), (2, "Viktor")],
    )

Each call to ``execute_write_many()`` will be executed inside a transaction.

.. _database_execute_write_fn:

await db.execute_write_fn(fn, block=True, transaction=True)
-----------------------------------------------------------

This method works like ``.execute_write()``, but instead of a SQL statement you give it a callable Python function. Your function will be queued up and then called when the write connection is available, passing that connection as the argument to the function.

The function can then perform multiple actions, safe in the knowledge that it has exclusive access to the single writable connection for as long as it is executing.

.. warning::

    ``fn`` needs to be a regular function, not an ``async def`` function.

For example:

.. code-block:: python

    def delete_and_return_count(conn):
        conn.execute("delete from some_table where id > 5")
        return conn.execute(
            "select count(*) from some_table"
        ).fetchone()[0]


    try:
        num_rows_left = await database.execute_write_fn(
            delete_and_return_count
        )
    except Exception as e:
        print("An error occurred:", e)

The value returned from ``await database.execute_write_fn(...)`` will be the return value from your function.

If your function raises an exception that exception will be propagated up to the ``await`` line.

By default your function will be executed inside a transaction. You can pass ``transaction=False`` to disable this behavior, though if you do that you should be careful to manually apply transactions - ideally using the ``with conn:`` pattern, or you may see ``OperationalError: database table is locked`` errors.

If you specify ``block=False`` the method becomes fire-and-forget, queueing your function to be executed and then allowing your code after the call to ``.execute_write_fn()`` to continue running while the underlying thread waits for an opportunity to run your function. A UUID representing the queued task will be returned. Any exceptions in your code will be silently swallowed.

.. _database_execute_isolated_fn:

await db.execute_isolated_fn(fn)
--------------------------------

This method works is similar to :ref:`execute_write_fn() <database_execute_write_fn>` but executes the provided function in an entirely isolated SQLite connection, which is opened, used and then closed again in a single call to this method.

The :ref:`prepare_connection() <plugin_hook_prepare_connection>` plugin hook is not executed against this connection.

This allows plugins to execute database operations that might conflict with how database connections are usually configured. For example, running a ``VACUUM`` operation while bypassing any restrictions placed by the `datasette-sqlite-authorizer <https://github.com/datasette/datasette-sqlite-authorizer>`__ plugin.

Plugins can also use this method to load potentially dangerous SQLite extensions, use them to perform an operation and then have them safely unloaded at the end of the call, without risk of exposing them to other connections.

Functions run using ``execute_isolated_fn()`` share the same queue as ``execute_write_fn()``, which guarantees that no writes can be executed at the same time as the isolated function is executing.

The return value of the function will be returned by this method. Any exceptions raised by the function will be raised out of the ``await`` line as well.

.. _database_close:

db.close()
----------

Closes all of the open connections to file-backed databases. This is mainly intended to be used by large test suites, to avoid hitting limits on the number of open files.

.. _internals_database_introspection:

Database introspection
----------------------

The ``Database`` class also provides properties and methods for introspecting the database.

``db.name`` - string
    The name of the database - usually the filename without the ``.db`` prefix.

``db.size`` - integer
    The size of the database file in bytes. 0 for ``:memory:`` databases.

``db.mtime_ns`` - integer or None
    The last modification time of the database file in nanoseconds since the epoch. ``None`` for ``:memory:`` databases.

``db.is_mutable`` - boolean
    Is this database mutable, and allowed to accept writes?

``db.is_memory`` - boolean
    Is this database an in-memory database?

``await db.attached_databases()`` - list of named tuples
    Returns a list of additional databases that have been connected to this database using the SQLite ATTACH command. Each named tuple has fields ``seq``, ``name`` and ``file``.

``await db.table_exists(table)`` - boolean
    Check if a table called ``table`` exists.

``await db.view_exists(view)`` - boolean
    Check if a view called ``view`` exists.

``await db.table_names()`` - list of strings
    List of names of tables in the database.

``await db.view_names()`` - list of strings
    List of names of views in the database.

``await db.table_columns(table)`` - list of strings
    Names of columns in a specific table.

``await db.table_column_details(table)`` - list of named tuples
    Full details of the columns in a specific table. Each column is represented by a ``Column`` named tuple with fields ``cid`` (integer representing the column position), ``name`` (string), ``type`` (string, e.g. ``REAL`` or ``VARCHAR(30)``), ``notnull`` (integer 1 or 0), ``default_value`` (string or None), ``is_pk`` (integer 1 or 0).

``await db.primary_keys(table)`` - list of strings
    Names of the columns that are part of the primary key for this table.

``await db.fts_table(table)`` - string or None
    The name of the FTS table associated with this table, if one exists.

``await db.label_column_for_table(table)`` - string or None
    The label column that is associated with this table - either automatically detected or using the ``"label_column"`` key from :ref:`metadata`, see :ref:`label_columns`.

``await db.foreign_keys_for_table(table)`` - list of dictionaries
    Details of columns in this table which are foreign keys to other tables. A list of dictionaries where each dictionary is shaped like this: ``{"column": string, "other_table": string, "other_column": string}``.

``await db.hidden_table_names()`` - list of strings
    List of tables which Datasette "hides" by default - usually these are tables associated with SQLite's full-text search feature, the SpatiaLite extension or tables hidden using the :ref:`metadata_hiding_tables` feature.

``await db.get_table_definition(table)`` - string
    Returns the SQL definition for the table - the ``CREATE TABLE`` statement and any associated ``CREATE INDEX`` statements.

``await db.get_view_definition(view)`` - string
    Returns the SQL definition of the named view.

``await db.get_all_foreign_keys()`` - dictionary
    Dictionary representing both incoming and outgoing foreign keys for this table. It has two keys, ``"incoming"`` and ``"outgoing"``, each of which is a list of dictionaries with keys ``"column"``, ``"other_table"`` and ``"other_column"``. For example:

    .. code-block:: json

        {
            "incoming": [],
            "outgoing": [
                {
                    "other_table": "attraction_characteristic",
                    "column": "characteristic_id",
                    "other_column": "pk",
                },
                {
                    "other_table": "roadside_attractions",
                    "column": "attraction_id",
                    "other_column": "pk",
                }
            ]
        }


.. _internals_csrf:

CSRF protection
===============

Datasette uses `asgi-csrf <https://github.com/simonw/asgi-csrf>`__ to guard against CSRF attacks on form POST submissions. Users receive a ``ds_csrftoken`` cookie which is compared against the ``csrftoken`` form field (or ``x-csrftoken`` HTTP header) for every incoming request.

If your plugin implements a ``<form method="POST">`` anywhere you will need to include that token. You can do so with the following template snippet:

.. code-block:: html

    <input type="hidden" name="csrftoken" value="{{ csrftoken() }}">

If you are rendering templates using the :ref:`datasette_render_template` method the ``csrftoken()`` helper will only work if you provide the ``request=`` argument to that method. If you forget to do this you will see the following error::

    form-urlencoded POST field did not match cookie

You can selectively disable CSRF protection using the :ref:`plugin_hook_skip_csrf` hook.

.. _internals_internal:

Datasette's internal database
=============================

Datasette maintains an "internal" SQLite database used for configuration, caching, and storage. Plugins can store configuration, settings, and other data inside this database. By default, Datasette will use a temporary in-memory SQLite database as the internal database, which is created at startup and destroyed at shutdown. Users of Datasette can optionally pass in a ``--internal`` flag to specify the path to a SQLite database to use as the internal database, which will persist internal data across Datasette instances.

Datasette maintains tables called ``catalog_databases``, ``catalog_tables``, ``catalog_columns``, ``catalog_indexes``, ``catalog_foreign_keys`` with details of the attached databases and their schemas. These tables should not be considered a stable API - they may change between Datasette releases.

Metadata is stored in tables ``metadata_instance``, ``metadata_databases``, ``metadata_resources`` and ``metadata_columns``. Plugins can interact with these tables via the :ref:`get_*_metadata() and set_*_metadata() methods <datasette_get_set_metadata>`.

The internal database is not exposed in the Datasette application by default, which means private data can safely be stored without worry of accidentally leaking information through the default Datasette interface and API. However, other plugins do have full read and write access to the internal database.

Plugins can access this database by calling ``internal_db = datasette.get_internal_database()`` and then executing queries using the :ref:`Database API <internals_database>`.

Plugin authors are asked to practice good etiquette when using the internal database, as all plugins use the same database to store data. For example:

1. Use a unique prefix when creating tables, indices, and triggers in the internal database. If your plugin is called ``datasette-xyz``, then prefix names with ``datasette_xyz_*``.
2. Avoid long-running write statements that may stall or block other plugins that are trying to write at the same time.
3. Use temporary tables or shared in-memory attached databases when possible.
4. Avoid implementing features that could expose private data stored in the internal database by other plugins.

.. _internals_internal_schema:

Internal database schema
------------------------

The internal database schema is as follows:

.. [[[cog
    from metadata_doc import internal_schema
    internal_schema(cog)
.. ]]]

.. code-block:: sql

    CREATE TABLE catalog_databases (
        database_name TEXT PRIMARY KEY,
        path TEXT,
        is_memory INTEGER,
        schema_version INTEGER
    );
    CREATE TABLE catalog_tables (
        database_name TEXT,
        table_name TEXT,
        rootpage INTEGER,
        sql TEXT,
        PRIMARY KEY (database_name, table_name),
        FOREIGN KEY (database_name) REFERENCES databases(database_name)
    );
    CREATE TABLE catalog_columns (
        database_name TEXT,
        table_name TEXT,
        cid INTEGER,
        name TEXT,
        type TEXT,
        "notnull" INTEGER,
        default_value TEXT, -- renamed from dflt_value
        is_pk INTEGER, -- renamed from pk
        hidden INTEGER,
        PRIMARY KEY (database_name, table_name, name),
        FOREIGN KEY (database_name) REFERENCES databases(database_name),
        FOREIGN KEY (database_name, table_name) REFERENCES tables(database_name, table_name)
    );
    CREATE TABLE catalog_indexes (
        database_name TEXT,
        table_name TEXT,
        seq INTEGER,
        name TEXT,
        "unique" INTEGER,
        origin TEXT,
        partial INTEGER,
        PRIMARY KEY (database_name, table_name, name),
        FOREIGN KEY (database_name) REFERENCES databases(database_name),
        FOREIGN KEY (database_name, table_name) REFERENCES tables(database_name, table_name)
    );
    CREATE TABLE catalog_foreign_keys (
        database_name TEXT,
        table_name TEXT,
        id INTEGER,
        seq INTEGER,
        "table" TEXT,
        "from" TEXT,
        "to" TEXT,
        on_update TEXT,
        on_delete TEXT,
        match TEXT,
        PRIMARY KEY (database_name, table_name, id, seq),
        FOREIGN KEY (database_name) REFERENCES databases(database_name),
        FOREIGN KEY (database_name, table_name) REFERENCES tables(database_name, table_name)
    );
    CREATE TABLE metadata_instance (
        key text,
        value text,
        unique(key)
    );
    CREATE TABLE metadata_databases (
        database_name text,
        key text,
        value text,
        unique(database_name, key)
    );
    CREATE TABLE metadata_resources (
        database_name text,
        resource_name text,
        key text,
        value text,
        unique(database_name, resource_name, key)
    );
    CREATE TABLE metadata_columns (
        database_name text,
        resource_name text,
        column_name text,
        key text,
        value text,
        unique(database_name, resource_name, column_name, key)
    );

.. [[[end]]]

.. _internals_utils:

The datasette.utils module
==========================

The ``datasette.utils`` module contains various utility functions used by Datasette. As a general rule you should consider anything in this module to be unstable - functions and classes here could change without warning or be removed entirely between Datasette releases, without being mentioned in the release notes.

The exception to this rule is anything that is documented here. If you find a need for an undocumented utility function in your own work, consider `opening an issue <https://github.com/simonw/datasette/issues/new>`__ requesting that the function you are using be upgraded to documented and supported status.

.. _internals_utils_parse_metadata:

parse_metadata(content)
-----------------------

This function accepts a string containing either JSON or YAML, expected to be of the format described in :ref:`metadata`. It returns a nested Python dictionary representing the parsed data from that string.

If the metadata cannot be parsed as either JSON or YAML the function will raise a ``utils.BadMetadataError`` exception.

.. autofunction:: datasette.utils.parse_metadata

.. _internals_utils_await_me_maybe:

await_me_maybe(value)
---------------------

Utility function for calling ``await`` on a return value if it is awaitable, otherwise returning the value. This is used by Datasette to support plugin hooks that can optionally return awaitable functions. Read more about this function in `The “await me maybe” pattern for Python asyncio <https://simonwillison.net/2020/Sep/2/await-me-maybe/>`__.

.. autofunction:: datasette.utils.await_me_maybe

.. _internals_utils_named_parameters:

named_parameters(sql)
---------------------

Derive the list of ``:named`` parameters referenced in a SQL query.

.. autofunction:: datasette.utils.named_parameters

.. _internals_tilde_encoding:

Tilde encoding
--------------

Datasette uses a custom encoding scheme in some places, called **tilde encoding**. This is primarily used for table names and row primary keys, to avoid any confusion between ``/`` characters in those values and the Datasette URLs that reference them.

Tilde encoding uses the same algorithm as `URL percent-encoding <https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding>`__, but with the ``~`` tilde character used in place of ``%``.

Any character other than ``ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz0123456789_-`` will be replaced by the numeric equivalent preceded by a tilde. For example:

- ``/`` becomes ``~2F``
- ``.`` becomes ``~2E``
- ``%`` becomes ``~25``
- ``~`` becomes ``~7E``
- Space becomes ``+``
- ``polls/2022.primary`` becomes ``polls~2F2022~2Eprimary``

Note that the space character is a special case: it will be replaced with a ``+`` symbol.

.. _internals_utils_tilde_encode:

.. autofunction:: datasette.utils.tilde_encode

.. _internals_utils_tilde_decode:

.. autofunction:: datasette.utils.tilde_decode

.. _internals_tracer:

datasette.tracer
================

Running Datasette with ``--setting trace_debug 1`` enables trace debug output, which can then be viewed by adding ``?_trace=1`` to the query string for any page.

You can see an example of this at the bottom of `latest.datasette.io/fixtures/facetable?_trace=1 <https://latest.datasette.io/fixtures/facetable?_trace=1>`__. The JSON output shows full details of every SQL query that was executed to generate the page.

The `datasette-pretty-traces <https://datasette.io/plugins/datasette-pretty-traces>`__ plugin can be installed to provide a more readable display of this information. You can see `a demo of that here <https://latest-with-plugins.datasette.io/github/commits?_trace=1>`__.

You can add your own custom traces to the JSON output using the ``trace()`` context manager. This takes a string that identifies the type of trace being recorded, and records any keyword arguments as additional JSON keys on the resulting trace object.

The start and end time, duration and a traceback of where the trace was executed will be automatically attached to the JSON object.

This example uses trace to record the start, end and duration of any HTTP GET requests made using the function:

.. code-block:: python

    from datasette.tracer import trace
    import httpx


    async def fetch_url(url):
        with trace("fetch-url", url=url):
            async with httpx.AsyncClient() as client:
                return await client.get(url)

.. _internals_tracer_trace_child_tasks:

Tracing child tasks
-------------------

If your code uses a mechanism such as ``asyncio.gather()`` to execute code in additional tasks you may find that some of the traces are missing from the display.

You can use the ``trace_child_tasks()`` context manager to ensure these child tasks are correctly handled.

.. code-block:: python

    from datasette import tracer

    with tracer.trace_child_tasks():
        results = await asyncio.gather(
            # ... async tasks here
        )

This example uses the :ref:`register_routes() <plugin_register_routes>` plugin hook to add a page at ``/parallel-queries`` which executes two SQL queries in parallel using ``asyncio.gather()`` and returns their results.

.. code-block:: python

    from datasette import hookimpl
    from datasette import tracer


    @hookimpl
    def register_routes():
        async def parallel_queries(datasette):
            db = datasette.get_database()
            with tracer.trace_child_tasks():
                one, two = await asyncio.gather(
                    db.execute("select 1"),
                    db.execute("select 2"),
                )
            return Response.json(
                {
                    "one": one.single_value(),
                    "two": two.single_value(),
                }
            )

        return [
            (r"/parallel-queries$", parallel_queries),
        ]

Note that running parallel SQL queries in this way has `been known to cause problems in the past <https://github.com/simonw/datasette/issues/2189>`__, so treat this example with caution.

Adding ``?_trace=1`` will show that the trace covers both of those child tasks.

.. _internals_shortcuts:

Import shortcuts
================

The following commonly used symbols can be imported directly from the ``datasette`` module:

.. code-block:: python

    from datasette import Response
    from datasette import Forbidden
    from datasette import NotFound
    from datasette import hookimpl
    from datasette import actor_matches_allow

</document_content>
</document>
</documents>
